<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="theme" content="Chirpy v2.7.2"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="数据加密" /><meta name="author" content="Narule" /><meta property="og:locale" content="en_US" /><meta name="description" content="网络数据加密 互联网，将全球不同的计算机等电子设备连接起来，使具备互相通信的条件，但是通信信息有些事隐私，有些通信不能被其他人知道。互联网私人生活交流信息不被恶意者随意窃取，也应该是社会秩序正常稳定的表现，平时的通信不过如此，涉及到商业信息，数据保密更显得格外重要。加密算法是保持通信信息不泄漏的一种技术，可用手段。’’ 前言 网络数据加密是必须做的事 安全正确必要性 互联网通信通过电缆或者无线设备，信息是可以被中间人收到记录的，所以要考虑很多风险因素，信息必须被加密处理只是其中之一的考虑 信息安全 明文可能被第三方劫持查看。 就像写信一样，A写信给B，在信件到达B手上之前，信件在途中可能被别人拆开看过然后再封装原样，使AB都不能发觉信息已经被第三个人看了。 信息正确 传输信息可能被修改 同样A给B写信，在途中信件被人劫持，如果信件途中被别人打开，替换里面的信息内容，B收到后的信息很可能是错误的。 网络也是一样，网络通信必须通过有线或者无线设备传输，所以一定是可以劫持的，明文通信没有隐私可言，极不安全，所以加密算法通常需要做的事 概念 参考文章 https://www.cnblogs.com/hulianwangjiagoushi/p/10671771.html 首先加密是因为存在网路信息传输，所以加密的使用过程分三步 举例 A计算机通过网络传输信息给B计算机，中间使用加密算法过程如下 A (明文 –&gt;加密–&gt;密文) ———–网络（密文）———–&gt; B（密文 –&gt;解密–&gt;明文） st=&gt;start: 明文 op1=&gt;operation: A端加密 op2=&gt;operation: 加密密文网络传输 cond=&gt;condition: 签名确认 是否为A端发送的加密数据? op3=&gt;operation: B端解密 op4=&gt;operation: 丢弃（被篡改）信息 e=&gt;end: 明文 st-&gt;op1-&gt;op2-&gt;cond op3-&gt;e cond(yes)-&gt;op3-&gt;e cond(no)-&gt;op4 #cond=&gt;condition: Yes or No? #cond(yes)-&gt;e #cond(no)-&gt;op 密钥 用于加密的根据，明文加密成密文的凭据，根据密钥有规则的加密，也只有根据密钥才能有规则的解密，应此通信中加密的密钥保管也很重要（不能被泄露） 明文 明文指两者通信的原文，能看懂的。 加密 将明文通过某种方式加密变成密文 密文 将明文加密后的信息，并且除了密钥，不能用其他方式将其解密成原文信息 传输 密文的传输（不怕别人看到密文，密文看不到真实信息，第三方不能获取有效信息） 解密 将密文还原成明文（接收者能看到明文） 签名 保证双方的信息真实没被修改的技术 A与B之间要有一种签名存在，在通信的时候，收到信息，通过签名要能鉴别信息是否被第三方修改或者信息是第三方伪造发送。 加密算法 信息加密是非常专业的计算知识，通过复杂设计，对信息数据加密，使不能被轻易破解。常见的加密算法都需要有密钥，通过密钥分类又可以分为对称加密和非对称加密。 对称加密指信息的加密和解密使用同一个密钥，非对称加密则是信息的加密和解密不是用到同一个密钥 对称加密 AES 密码学中的高级加密标准（Advanced Encryption Standard，AES） 这个标准用来替代原先的DES（Data Encryption Standard），已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院 （NIST）于2001年11月26日发布于FIPS PUB 197，并在2002年5月26日成为有效的标准。2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一 [1] 。 该算法为比利时密码学家Joan Daemen和Vincent Rijmen所设计，结合两位作者的名字，以Rijdael之名命之，投稿高级加密标准的甄选流程。（Rijdael的发音近于 “Rhine doll”。） 原理 AES加密数据块和密钥长度可以是128b、192b、256b中的任意一个。AES加密有很多轮的重复和变换。大致步骤如下：①密钥扩展（Key Expansion)；②初始轮（InitialRound)；③重复轮（Rounds），每一重复轮又包括字节间减法运算（SubBytes）、行移位（ShiftRows）、列混合（MixColumns)、轮密钥加法运算（AddRoundKey)等操作；①最终轮（Final Round)，最终轮没有列混合操作（MixColumns)。 相关文章介绍： https://blog.csdn.net/zxh2075/article/details/80630296 https://www.jianshu.com/p/79a225c2650e https://blog.csdn.net/huangxiaoguo1/article/details/78043169 加密过程 128位密钥加密流程简略描述： st=&gt;start: 待加密明文 op0=&gt;operation: 明文与密钥异或运算 op1=&gt;operation: 获取加密密钥，设置填充方式 op2=&gt;operation: 加密（信息+密钥 规律运算） cond1=&gt;condition: 循环了9次？ op3=&gt;operation: 第十次加密运算（区别于前面9次） op4=&gt;operation: （明文+密钥）规律位运算调整 e=&gt;end: AES加密密文 st-&gt;op0-&gt;op2-&gt;cond1 op3-&gt;e cond1(yes)-&gt;op3 cond1(no)-&gt;op4-&gt;op2 解密（逆运算） 因为明文加密10轮是根据密钥有规律的复杂运算，因此解密就是上述过程的逆运算，只要有密钥，就能通过规律逆运算得到明文 加密模式 对称/分组密码一般分为流加密(如OFB、CFB等)和块加密(如ECB、CBC等)。对于流加密，需要将分组密码转化为流模式工作。对于块加密(或称分组加密)，如果要加密超过块大小的数据，就需要涉及填充和链加密模式。 ECB ECB(Electronic Code Book电子密码本)模式 ECB模式是最早采用和最简单的模式，它将加密的数据分成若干组，每组的大小跟加密密钥长度相同，然后每组都用相同的密钥进行加密。 CBC CBC(Cipher Block Chaining，加密块链)模式 这种模式是先将明文切分成若干小段，然后每一小段与初始块或者上一段的密文段进行异或运算后，再与密钥进行加密。 java使用AES加密 AesCrypto.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 package com.emoyc.note.common.util.encryption.aes; import javax.crypto.Cipher; import javax.crypto.KeyGenerator; import javax.crypto.spec.IvParameterSpec; import javax.crypto.spec.SecretKeySpec; /** * AES加密 * @author Narule * */ public class AesCrypto { /** * AES加密模式 */ private static final String ECB_MODE = &quot;AES/ECB/PKCS5Padding&quot;; private static final String CBC_MODE = &quot;AES/CBC/PKCS5Padding&quot;; /** * AES ECB模式加密 * @param content 待加密的内容 * @param encryptKey 加密密钥 * @return 加密后的byte[] * @throws Exception */ public static byte[] aesEncryptToBytes_ECB(byte[] contentBytes, byte[] keyBytes) throws Exception { KeyGenerator kgen = KeyGenerator.getInstance(&quot;AES&quot;); kgen.init(128); Cipher cipher = Cipher.getInstance(ECB_MODE); cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(keyBytes, &quot;AES&quot;)); return cipher.doFinal(contentBytes); } /** * AES ECB模式解密 * @param encryptBytes 待解密的byte[] * @param decryptKey 解密密钥 * @return 解密后的String * @throws Exception */ public static byte[] aesDecryptByBytes_ECB(byte[] encryptBytes, byte[] keyBytes) throws Exception { KeyGenerator kgen = KeyGenerator.getInstance(&quot;AES&quot;); kgen.init(128); Cipher cipher = Cipher.getInstance(ECB_MODE); cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(keyBytes, &quot;AES&quot;)); return cipher.doFinal(encryptBytes); } /** * AES CBC模式加密 * @throws Exception */ public static byte[] aesEncryptToBytes_CBC(byte[] encryptBytes, byte[] ivBytes,byte[] keyBytes) throws Exception { SecretKeySpec key = new SecretKeySpec(keyBytes, &quot;AES&quot;); IvParameterSpec IV = new IvParameterSpec(ivBytes); Cipher c = Cipher.getInstance(CBC_MODE); c.init(Cipher.ENCRYPT_MODE, key, IV); return c.doFinal(encryptBytes); } /** * AES CBC模式解密 * @throws Exception */ public static byte[] aesDecryptByBytes_CBC(byte[] decryptBytes, byte[] ivBytes,byte[] keyBytes) throws Exception { SecretKeySpec key = new SecretKeySpec(keyBytes, &quot;AES&quot;); IvParameterSpec IV = new IvParameterSpec(ivBytes); Cipher c = Cipher.getInstance(CBC_MODE); c.init(Cipher.DECRYPT_MODE, key, IV); return c.doFinal(decryptBytes); } } AesUtil.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 package com.emoyc.note.common.util.encryption.aes; /** * AES 加密整合工具类 * @author Narule * */ public class AesUtil { /** * AES临时KEY */ private static final String KEY = &quot;jdkcnvlao903nhfl&quot;; /** * AES-ECB 加密模式 * @param content //原文 * @param key * @return _encrypt //密文 * @throws Exception */ public final static String aesEncrypt_ECB(String content,String key) throws Exception { return base64Encode( AesCrypto.aesEncryptToBytes_ECB(content.getBytes(), key.getBytes()) ); } /** * AES-ECB 解密模式 * @param content //密文 * @param key * @return _decrypt //原文 * @throws Exception */ public final static String aesDecrypt_ECB(String content,String key) throws Exception { return new String( AesCrypto.aesDecryptByBytes_ECB(base64Decode(content), key.getBytes()) ); } /** * AES-CBC 加密模式 * @param content //原文 * @param key * @return _encrypt //密文 * @throws Exception */ public final static String aesEncrypt_CBC(String content,String key) throws Exception { return base64Encode( AesCrypto.aesEncryptToBytes_CBC(content.getBytes(), key.getBytes(),key.getBytes()) ); } /** * AES-CBC 解密模式 * @param content //密文 * @param key * @return _decrypt //原文 * @throws Exception */ public final static String aesDecrypt_CBC(String content,String key) throws Exception { return new String( AesCrypto.aesDecryptByBytes_CBC(base64Decode(content), key.getBytes(), key.getBytes()) ); } /** * base 64 encode * @param bytes 待编码的byte[] * @return 编码后的base 64 code */ public static String base64Encode(byte[] bytes){ return java.util.Base64.getEncoder().encodeToString(bytes); } /** * base 64 decode * @param base64Code 待解码的base 64 code * @return 解码后的byte[] * @throws Exception */ public static byte[] base64Decode(String base64Code) throws Exception{ return (base64Code == null || base64Code.length() == 0) ? null : java.util.Base64.getDecoder().decode(base64Code); } public static void main(String[] args) { String string = &quot;吴楠予&quot;; testAes_ECB(string); testAes_CBC(string); } private static void testAes_ECB(String string) { System.out.println(&quot;===================ECB加密=================&quot;); System.out.println(&quot;明文：&quot; ); System.out.println(string); String aesEncrypt_ECB = null; String aesDecrypt_ECB = null; try { aesEncrypt_ECB = aesEncrypt_ECB(string, KEY); System.out.println(&quot;密文：&quot;); System.out.println(aesEncrypt_ECB); aesDecrypt_ECB = aesDecrypt_ECB(aesEncrypt_ECB, KEY); System.out.println(&quot;解密后：&quot;); System.out.println(aesDecrypt_ECB); } catch (Exception e) { e.printStackTrace(); } } private static void testAes_CBC(String string) { System.out.println(&quot;===================CBC加密=================&quot;); System.out.println(&quot;明文：&quot; ); System.out.println(string); String aesEncrypt_CBC = null; String aesDecrypt_CBC = null; try { aesEncrypt_CBC = aesEncrypt_CBC(string, KEY); System.out.println(&quot;密文：&quot;); System.out.println(aesEncrypt_CBC); aesDecrypt_CBC = aesDecrypt_CBC(aesEncrypt_CBC, KEY); System.out.println(&quot;解密后：&quot;); System.out.println(aesDecrypt_CBC); } catch (Exception e) { e.printStackTrace(); } } } 加解密Test 运行AesUtil的main方法： 非对称加密 RSA 参考文章 http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html https://www.jianshu.com/p/ca659dbc6f46 通过上面的文章自己实践测试，数字小，但是不影响 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 p = 3 q = 5 n = 3 * 5 = 15 n&#39; = 2 * 4 = 8 选一个数 e 与 8 互质 e = 7 7 * x + 8 * y = 1 x = 7 = d y = -6 加密 3 3^7 = 2187 2187%15 = 12 12^7%15 = 3 e = ３ 3 * x + 8 * y = 1 x = 11 = d y = -4 加密 3 3^3 = 27 27%15 = 12 12^11%15 = 3 java使用RSA加密工具 RsaUtil.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 package com.emoyc.note.common.util.encryption.rsa; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.InputStream; import java.io.OutputStream; import java.security.KeyPair; /** * RSA 加密工具整合类 * @author Narule * */ public class RsaUtil { private static byte[] publicKey; private static byte[] privateKey; /** * main方法 - RSA 加密解密测试 * @param args * @throws Exception */ public static void main(String[] args) throws Exception { createKey(); initKey(); String str = &quot;吴楠予&quot;; byte[] encryptData = RsaCrypto.encryptData(str.getBytes(), publicKey); System.out.println(&quot;=========加密===============&quot;); System.out.println(new String(encryptData)); System.out.println(&quot;=========解密===============&quot;); byte[] decryptData = RsaCrypto.decryptData(encryptData, privateKey); System.out.println(new String(decryptData)); } /** * createKey 创建RSA 密钥对 */ private static void createKey() { try { KeyPair generateKeyPair = RsaCrypto.creatKey(); byteToFile(generateKeyPair.getPublic().getEncoded(), &quot;./rsa_2048_pubkey.txt&quot;); byteToFile(generateKeyPair.getPrivate().getEncoded(), &quot;./rsa_2048_prikey.txt&quot;); } catch (Exception e) { e.printStackTrace(); } } public static KeyPair getOneRsaKey() { try { return RsaCrypto.creatKey(); } catch (Exception e) { e.printStackTrace(); } return null; } /** * readKey 读取密钥文件 */ private static void initKey() { try { publicKey = fileToByte(&quot;./rsa_2048_pubkey.txt&quot;); privateKey = fileToByte(&quot;./rsa_2048_prikey.txt&quot;); } catch (Exception e) { e.printStackTrace(); } } /** * byte-&gt;file 二进制数据转文件 * @param bytes * @param filePath * @throws Exception */ public static void byteToFile(byte[] bytes, String filePath) throws Exception { InputStream in = new ByteArrayInputStream(bytes); File destFile = new File(filePath); if (!destFile.getParentFile().exists()) { destFile.getParentFile().mkdirs(); } destFile.createNewFile(); OutputStream out = new FileOutputStream(destFile); byte[] cache = new byte[2048]; int nRead = 0; while ((nRead = in.read(cache)) != -1) { out.write(cache, 0, nRead); out.flush(); } out.close(); in.close(); } /** * file-&gt;byte 文件转二进制 * @param filePath * @return * @throws Exception */ public static byte[] fileToByte(String filePath) throws Exception { byte[] data = new byte[0]; File file = new File(filePath); if (file.exists()) { FileInputStream in = new FileInputStream(file); ByteArrayOutputStream out = new ByteArrayOutputStream(2048); byte[] cache = new byte[2048]; int nRead = 0; while ((nRead = in.read(cache)) != -1) { out.write(cache, 0, nRead); out.flush(); } out.close(); in.close(); data = out.toByteArray(); } return data; } } RsaCrypto.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 package com.emoyc.note.common.util.encryption.rsa; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.security.Key; import java.security.KeyFactory; import java.security.KeyPair; import java.security.KeyPairGenerator; import java.security.PublicKey; import java.security.spec.PKCS8EncodedKeySpec; import java.security.spec.X509EncodedKeySpec; import javax.crypto.Cipher; /** * RSA 加密解密类 * @author Narule * */ public class RsaCrypto { private static final String ALGORITHM_RSA = &quot;RSA&quot;; /** */ /** * RSA最大加密明文大小 */ // 2048 private static final int MAX_ENCRYPT_BLOCK = 245; /** */ /** * RSA最大解密密文大小 */ // 2048 private static final int MAX_DECRYPT_BLOCK = 256; public static KeyPair creatKey() throws Exception { KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(ALGORITHM_RSA); keyPairGenerator.initialize(2048); return keyPairGenerator.generateKeyPair(); } /** * RSA 公钥加密 * * @param data * @param key * @return * @throws Exception */ public static byte[] encryptData(byte[] data, byte[] key) { ByteArrayOutputStream out = null; byte[] encryptedData = null; try { X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(key); KeyFactory keyFactory = KeyFactory.getInstance(ALGORITHM_RSA); PublicKey generatePublic = keyFactory.generatePublic(x509KeySpec); // 对数据加密 Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(Cipher.ENCRYPT_MODE, generatePublic); int inputLen = data.length; out = new ByteArrayOutputStream(); int offSet = 0; byte[] cache; int i = 0; // 对数据分段加密 while (inputLen - offSet &gt; 0) { if (inputLen - offSet &gt; MAX_ENCRYPT_BLOCK) { cache = cipher.doFinal(data, offSet, MAX_ENCRYPT_BLOCK); } else { cache = cipher.doFinal(data, offSet, inputLen - offSet); } out.write(cache, 0, cache.length); i++; offSet = i * MAX_ENCRYPT_BLOCK; } encryptedData = out.toByteArray(); out.close(); } catch (Exception e) { e.printStackTrace(); } finally { // 防止流未关闭 浪费占用资源 if (out != null) { try { out.close(); } catch (IOException e) { e.printStackTrace(); } } } return encryptedData; } /** * RSA 私钥解密 * * @param data * @param key * @return * @throws Exception */ public static byte[] decryptData(byte[] data, byte[] key) { ByteArrayOutputStream out = null; byte[] decryptedData = null; try { PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(key); KeyFactory keyFactory = KeyFactory.getInstance(ALGORITHM_RSA); Key privateK = keyFactory.generatePrivate(pkcs8KeySpec); Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(Cipher.DECRYPT_MODE, privateK); out = new ByteArrayOutputStream(); int inputLen = data.length; int offSet = 0; byte[] cache; int i = 0; // 对数据分段解密 while (inputLen - offSet &gt; 0) { if (inputLen - offSet &gt; MAX_DECRYPT_BLOCK) { cache = cipher.doFinal(data, offSet, MAX_DECRYPT_BLOCK); } else { cache = cipher.doFinal(data, offSet, inputLen - offSet); } out.write(cache, 0, cache.length); i++; offSet = i * MAX_DECRYPT_BLOCK; } decryptedData = out.toByteArray(); out.close(); } catch (Exception e) { e.printStackTrace(); } finally { // 防止流未关闭 浪费占用资源 if (out != null) { try { out.close(); } catch (IOException e) { e.printStackTrace(); } } } return decryptedData; } } 其他" /><meta property="og:description" content="网络数据加密 互联网，将全球不同的计算机等电子设备连接起来，使具备互相通信的条件，但是通信信息有些事隐私，有些通信不能被其他人知道。互联网私人生活交流信息不被恶意者随意窃取，也应该是社会秩序正常稳定的表现，平时的通信不过如此，涉及到商业信息，数据保密更显得格外重要。加密算法是保持通信信息不泄漏的一种技术，可用手段。’’ 前言 网络数据加密是必须做的事 安全正确必要性 互联网通信通过电缆或者无线设备，信息是可以被中间人收到记录的，所以要考虑很多风险因素，信息必须被加密处理只是其中之一的考虑 信息安全 明文可能被第三方劫持查看。 就像写信一样，A写信给B，在信件到达B手上之前，信件在途中可能被别人拆开看过然后再封装原样，使AB都不能发觉信息已经被第三个人看了。 信息正确 传输信息可能被修改 同样A给B写信，在途中信件被人劫持，如果信件途中被别人打开，替换里面的信息内容，B收到后的信息很可能是错误的。 网络也是一样，网络通信必须通过有线或者无线设备传输，所以一定是可以劫持的，明文通信没有隐私可言，极不安全，所以加密算法通常需要做的事 概念 参考文章 https://www.cnblogs.com/hulianwangjiagoushi/p/10671771.html 首先加密是因为存在网路信息传输，所以加密的使用过程分三步 举例 A计算机通过网络传输信息给B计算机，中间使用加密算法过程如下 A (明文 –&gt;加密–&gt;密文) ———–网络（密文）———–&gt; B（密文 –&gt;解密–&gt;明文） st=&gt;start: 明文 op1=&gt;operation: A端加密 op2=&gt;operation: 加密密文网络传输 cond=&gt;condition: 签名确认 是否为A端发送的加密数据? op3=&gt;operation: B端解密 op4=&gt;operation: 丢弃（被篡改）信息 e=&gt;end: 明文 st-&gt;op1-&gt;op2-&gt;cond op3-&gt;e cond(yes)-&gt;op3-&gt;e cond(no)-&gt;op4 #cond=&gt;condition: Yes or No? #cond(yes)-&gt;e #cond(no)-&gt;op 密钥 用于加密的根据，明文加密成密文的凭据，根据密钥有规则的加密，也只有根据密钥才能有规则的解密，应此通信中加密的密钥保管也很重要（不能被泄露） 明文 明文指两者通信的原文，能看懂的。 加密 将明文通过某种方式加密变成密文 密文 将明文加密后的信息，并且除了密钥，不能用其他方式将其解密成原文信息 传输 密文的传输（不怕别人看到密文，密文看不到真实信息，第三方不能获取有效信息） 解密 将密文还原成明文（接收者能看到明文） 签名 保证双方的信息真实没被修改的技术 A与B之间要有一种签名存在，在通信的时候，收到信息，通过签名要能鉴别信息是否被第三方修改或者信息是第三方伪造发送。 加密算法 信息加密是非常专业的计算知识，通过复杂设计，对信息数据加密，使不能被轻易破解。常见的加密算法都需要有密钥，通过密钥分类又可以分为对称加密和非对称加密。 对称加密指信息的加密和解密使用同一个密钥，非对称加密则是信息的加密和解密不是用到同一个密钥 对称加密 AES 密码学中的高级加密标准（Advanced Encryption Standard，AES） 这个标准用来替代原先的DES（Data Encryption Standard），已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院 （NIST）于2001年11月26日发布于FIPS PUB 197，并在2002年5月26日成为有效的标准。2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一 [1] 。 该算法为比利时密码学家Joan Daemen和Vincent Rijmen所设计，结合两位作者的名字，以Rijdael之名命之，投稿高级加密标准的甄选流程。（Rijdael的发音近于 “Rhine doll”。） 原理 AES加密数据块和密钥长度可以是128b、192b、256b中的任意一个。AES加密有很多轮的重复和变换。大致步骤如下：①密钥扩展（Key Expansion)；②初始轮（InitialRound)；③重复轮（Rounds），每一重复轮又包括字节间减法运算（SubBytes）、行移位（ShiftRows）、列混合（MixColumns)、轮密钥加法运算（AddRoundKey)等操作；①最终轮（Final Round)，最终轮没有列混合操作（MixColumns)。 相关文章介绍： https://blog.csdn.net/zxh2075/article/details/80630296 https://www.jianshu.com/p/79a225c2650e https://blog.csdn.net/huangxiaoguo1/article/details/78043169 加密过程 128位密钥加密流程简略描述： st=&gt;start: 待加密明文 op0=&gt;operation: 明文与密钥异或运算 op1=&gt;operation: 获取加密密钥，设置填充方式 op2=&gt;operation: 加密（信息+密钥 规律运算） cond1=&gt;condition: 循环了9次？ op3=&gt;operation: 第十次加密运算（区别于前面9次） op4=&gt;operation: （明文+密钥）规律位运算调整 e=&gt;end: AES加密密文 st-&gt;op0-&gt;op2-&gt;cond1 op3-&gt;e cond1(yes)-&gt;op3 cond1(no)-&gt;op4-&gt;op2 解密（逆运算） 因为明文加密10轮是根据密钥有规律的复杂运算，因此解密就是上述过程的逆运算，只要有密钥，就能通过规律逆运算得到明文 加密模式 对称/分组密码一般分为流加密(如OFB、CFB等)和块加密(如ECB、CBC等)。对于流加密，需要将分组密码转化为流模式工作。对于块加密(或称分组加密)，如果要加密超过块大小的数据，就需要涉及填充和链加密模式。 ECB ECB(Electronic Code Book电子密码本)模式 ECB模式是最早采用和最简单的模式，它将加密的数据分成若干组，每组的大小跟加密密钥长度相同，然后每组都用相同的密钥进行加密。 CBC CBC(Cipher Block Chaining，加密块链)模式 这种模式是先将明文切分成若干小段，然后每一小段与初始块或者上一段的密文段进行异或运算后，再与密钥进行加密。 java使用AES加密 AesCrypto.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 package com.emoyc.note.common.util.encryption.aes; import javax.crypto.Cipher; import javax.crypto.KeyGenerator; import javax.crypto.spec.IvParameterSpec; import javax.crypto.spec.SecretKeySpec; /** * AES加密 * @author Narule * */ public class AesCrypto { /** * AES加密模式 */ private static final String ECB_MODE = &quot;AES/ECB/PKCS5Padding&quot;; private static final String CBC_MODE = &quot;AES/CBC/PKCS5Padding&quot;; /** * AES ECB模式加密 * @param content 待加密的内容 * @param encryptKey 加密密钥 * @return 加密后的byte[] * @throws Exception */ public static byte[] aesEncryptToBytes_ECB(byte[] contentBytes, byte[] keyBytes) throws Exception { KeyGenerator kgen = KeyGenerator.getInstance(&quot;AES&quot;); kgen.init(128); Cipher cipher = Cipher.getInstance(ECB_MODE); cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(keyBytes, &quot;AES&quot;)); return cipher.doFinal(contentBytes); } /** * AES ECB模式解密 * @param encryptBytes 待解密的byte[] * @param decryptKey 解密密钥 * @return 解密后的String * @throws Exception */ public static byte[] aesDecryptByBytes_ECB(byte[] encryptBytes, byte[] keyBytes) throws Exception { KeyGenerator kgen = KeyGenerator.getInstance(&quot;AES&quot;); kgen.init(128); Cipher cipher = Cipher.getInstance(ECB_MODE); cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(keyBytes, &quot;AES&quot;)); return cipher.doFinal(encryptBytes); } /** * AES CBC模式加密 * @throws Exception */ public static byte[] aesEncryptToBytes_CBC(byte[] encryptBytes, byte[] ivBytes,byte[] keyBytes) throws Exception { SecretKeySpec key = new SecretKeySpec(keyBytes, &quot;AES&quot;); IvParameterSpec IV = new IvParameterSpec(ivBytes); Cipher c = Cipher.getInstance(CBC_MODE); c.init(Cipher.ENCRYPT_MODE, key, IV); return c.doFinal(encryptBytes); } /** * AES CBC模式解密 * @throws Exception */ public static byte[] aesDecryptByBytes_CBC(byte[] decryptBytes, byte[] ivBytes,byte[] keyBytes) throws Exception { SecretKeySpec key = new SecretKeySpec(keyBytes, &quot;AES&quot;); IvParameterSpec IV = new IvParameterSpec(ivBytes); Cipher c = Cipher.getInstance(CBC_MODE); c.init(Cipher.DECRYPT_MODE, key, IV); return c.doFinal(decryptBytes); } } AesUtil.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 package com.emoyc.note.common.util.encryption.aes; /** * AES 加密整合工具类 * @author Narule * */ public class AesUtil { /** * AES临时KEY */ private static final String KEY = &quot;jdkcnvlao903nhfl&quot;; /** * AES-ECB 加密模式 * @param content //原文 * @param key * @return _encrypt //密文 * @throws Exception */ public final static String aesEncrypt_ECB(String content,String key) throws Exception { return base64Encode( AesCrypto.aesEncryptToBytes_ECB(content.getBytes(), key.getBytes()) ); } /** * AES-ECB 解密模式 * @param content //密文 * @param key * @return _decrypt //原文 * @throws Exception */ public final static String aesDecrypt_ECB(String content,String key) throws Exception { return new String( AesCrypto.aesDecryptByBytes_ECB(base64Decode(content), key.getBytes()) ); } /** * AES-CBC 加密模式 * @param content //原文 * @param key * @return _encrypt //密文 * @throws Exception */ public final static String aesEncrypt_CBC(String content,String key) throws Exception { return base64Encode( AesCrypto.aesEncryptToBytes_CBC(content.getBytes(), key.getBytes(),key.getBytes()) ); } /** * AES-CBC 解密模式 * @param content //密文 * @param key * @return _decrypt //原文 * @throws Exception */ public final static String aesDecrypt_CBC(String content,String key) throws Exception { return new String( AesCrypto.aesDecryptByBytes_CBC(base64Decode(content), key.getBytes(), key.getBytes()) ); } /** * base 64 encode * @param bytes 待编码的byte[] * @return 编码后的base 64 code */ public static String base64Encode(byte[] bytes){ return java.util.Base64.getEncoder().encodeToString(bytes); } /** * base 64 decode * @param base64Code 待解码的base 64 code * @return 解码后的byte[] * @throws Exception */ public static byte[] base64Decode(String base64Code) throws Exception{ return (base64Code == null || base64Code.length() == 0) ? null : java.util.Base64.getDecoder().decode(base64Code); } public static void main(String[] args) { String string = &quot;吴楠予&quot;; testAes_ECB(string); testAes_CBC(string); } private static void testAes_ECB(String string) { System.out.println(&quot;===================ECB加密=================&quot;); System.out.println(&quot;明文：&quot; ); System.out.println(string); String aesEncrypt_ECB = null; String aesDecrypt_ECB = null; try { aesEncrypt_ECB = aesEncrypt_ECB(string, KEY); System.out.println(&quot;密文：&quot;); System.out.println(aesEncrypt_ECB); aesDecrypt_ECB = aesDecrypt_ECB(aesEncrypt_ECB, KEY); System.out.println(&quot;解密后：&quot;); System.out.println(aesDecrypt_ECB); } catch (Exception e) { e.printStackTrace(); } } private static void testAes_CBC(String string) { System.out.println(&quot;===================CBC加密=================&quot;); System.out.println(&quot;明文：&quot; ); System.out.println(string); String aesEncrypt_CBC = null; String aesDecrypt_CBC = null; try { aesEncrypt_CBC = aesEncrypt_CBC(string, KEY); System.out.println(&quot;密文：&quot;); System.out.println(aesEncrypt_CBC); aesDecrypt_CBC = aesDecrypt_CBC(aesEncrypt_CBC, KEY); System.out.println(&quot;解密后：&quot;); System.out.println(aesDecrypt_CBC); } catch (Exception e) { e.printStackTrace(); } } } 加解密Test 运行AesUtil的main方法： 非对称加密 RSA 参考文章 http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html https://www.jianshu.com/p/ca659dbc6f46 通过上面的文章自己实践测试，数字小，但是不影响 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 p = 3 q = 5 n = 3 * 5 = 15 n&#39; = 2 * 4 = 8 选一个数 e 与 8 互质 e = 7 7 * x + 8 * y = 1 x = 7 = d y = -6 加密 3 3^7 = 2187 2187%15 = 12 12^7%15 = 3 e = ３ 3 * x + 8 * y = 1 x = 11 = d y = -4 加密 3 3^3 = 27 27%15 = 12 12^11%15 = 3 java使用RSA加密工具 RsaUtil.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 package com.emoyc.note.common.util.encryption.rsa; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.InputStream; import java.io.OutputStream; import java.security.KeyPair; /** * RSA 加密工具整合类 * @author Narule * */ public class RsaUtil { private static byte[] publicKey; private static byte[] privateKey; /** * main方法 - RSA 加密解密测试 * @param args * @throws Exception */ public static void main(String[] args) throws Exception { createKey(); initKey(); String str = &quot;吴楠予&quot;; byte[] encryptData = RsaCrypto.encryptData(str.getBytes(), publicKey); System.out.println(&quot;=========加密===============&quot;); System.out.println(new String(encryptData)); System.out.println(&quot;=========解密===============&quot;); byte[] decryptData = RsaCrypto.decryptData(encryptData, privateKey); System.out.println(new String(decryptData)); } /** * createKey 创建RSA 密钥对 */ private static void createKey() { try { KeyPair generateKeyPair = RsaCrypto.creatKey(); byteToFile(generateKeyPair.getPublic().getEncoded(), &quot;./rsa_2048_pubkey.txt&quot;); byteToFile(generateKeyPair.getPrivate().getEncoded(), &quot;./rsa_2048_prikey.txt&quot;); } catch (Exception e) { e.printStackTrace(); } } public static KeyPair getOneRsaKey() { try { return RsaCrypto.creatKey(); } catch (Exception e) { e.printStackTrace(); } return null; } /** * readKey 读取密钥文件 */ private static void initKey() { try { publicKey = fileToByte(&quot;./rsa_2048_pubkey.txt&quot;); privateKey = fileToByte(&quot;./rsa_2048_prikey.txt&quot;); } catch (Exception e) { e.printStackTrace(); } } /** * byte-&gt;file 二进制数据转文件 * @param bytes * @param filePath * @throws Exception */ public static void byteToFile(byte[] bytes, String filePath) throws Exception { InputStream in = new ByteArrayInputStream(bytes); File destFile = new File(filePath); if (!destFile.getParentFile().exists()) { destFile.getParentFile().mkdirs(); } destFile.createNewFile(); OutputStream out = new FileOutputStream(destFile); byte[] cache = new byte[2048]; int nRead = 0; while ((nRead = in.read(cache)) != -1) { out.write(cache, 0, nRead); out.flush(); } out.close(); in.close(); } /** * file-&gt;byte 文件转二进制 * @param filePath * @return * @throws Exception */ public static byte[] fileToByte(String filePath) throws Exception { byte[] data = new byte[0]; File file = new File(filePath); if (file.exists()) { FileInputStream in = new FileInputStream(file); ByteArrayOutputStream out = new ByteArrayOutputStream(2048); byte[] cache = new byte[2048]; int nRead = 0; while ((nRead = in.read(cache)) != -1) { out.write(cache, 0, nRead); out.flush(); } out.close(); in.close(); data = out.toByteArray(); } return data; } } RsaCrypto.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 package com.emoyc.note.common.util.encryption.rsa; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.security.Key; import java.security.KeyFactory; import java.security.KeyPair; import java.security.KeyPairGenerator; import java.security.PublicKey; import java.security.spec.PKCS8EncodedKeySpec; import java.security.spec.X509EncodedKeySpec; import javax.crypto.Cipher; /** * RSA 加密解密类 * @author Narule * */ public class RsaCrypto { private static final String ALGORITHM_RSA = &quot;RSA&quot;; /** */ /** * RSA最大加密明文大小 */ // 2048 private static final int MAX_ENCRYPT_BLOCK = 245; /** */ /** * RSA最大解密密文大小 */ // 2048 private static final int MAX_DECRYPT_BLOCK = 256; public static KeyPair creatKey() throws Exception { KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(ALGORITHM_RSA); keyPairGenerator.initialize(2048); return keyPairGenerator.generateKeyPair(); } /** * RSA 公钥加密 * * @param data * @param key * @return * @throws Exception */ public static byte[] encryptData(byte[] data, byte[] key) { ByteArrayOutputStream out = null; byte[] encryptedData = null; try { X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(key); KeyFactory keyFactory = KeyFactory.getInstance(ALGORITHM_RSA); PublicKey generatePublic = keyFactory.generatePublic(x509KeySpec); // 对数据加密 Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(Cipher.ENCRYPT_MODE, generatePublic); int inputLen = data.length; out = new ByteArrayOutputStream(); int offSet = 0; byte[] cache; int i = 0; // 对数据分段加密 while (inputLen - offSet &gt; 0) { if (inputLen - offSet &gt; MAX_ENCRYPT_BLOCK) { cache = cipher.doFinal(data, offSet, MAX_ENCRYPT_BLOCK); } else { cache = cipher.doFinal(data, offSet, inputLen - offSet); } out.write(cache, 0, cache.length); i++; offSet = i * MAX_ENCRYPT_BLOCK; } encryptedData = out.toByteArray(); out.close(); } catch (Exception e) { e.printStackTrace(); } finally { // 防止流未关闭 浪费占用资源 if (out != null) { try { out.close(); } catch (IOException e) { e.printStackTrace(); } } } return encryptedData; } /** * RSA 私钥解密 * * @param data * @param key * @return * @throws Exception */ public static byte[] decryptData(byte[] data, byte[] key) { ByteArrayOutputStream out = null; byte[] decryptedData = null; try { PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(key); KeyFactory keyFactory = KeyFactory.getInstance(ALGORITHM_RSA); Key privateK = keyFactory.generatePrivate(pkcs8KeySpec); Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(Cipher.DECRYPT_MODE, privateK); out = new ByteArrayOutputStream(); int inputLen = data.length; int offSet = 0; byte[] cache; int i = 0; // 对数据分段解密 while (inputLen - offSet &gt; 0) { if (inputLen - offSet &gt; MAX_DECRYPT_BLOCK) { cache = cipher.doFinal(data, offSet, MAX_DECRYPT_BLOCK); } else { cache = cipher.doFinal(data, offSet, inputLen - offSet); } out.write(cache, 0, cache.length); i++; offSet = i * MAX_DECRYPT_BLOCK; } decryptedData = out.toByteArray(); out.close(); } catch (Exception e) { e.printStackTrace(); } finally { // 防止流未关闭 浪费占用资源 if (out != null) { try { out.close(); } catch (IOException e) { e.printStackTrace(); } } } return decryptedData; } } 其他" /><link rel="canonical" href="https://narule.github.io/posts/%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/" /><meta property="og:url" content="https://narule.github.io/posts/%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/" /><meta property="og:site_name" content="Narule" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-05-22T23:10:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="数据加密" /><meta name="twitter:site" content="@no_twitter" /><meta name="twitter:creator" content="@Narule" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"网络数据加密 互联网，将全球不同的计算机等电子设备连接起来，使具备互相通信的条件，但是通信信息有些事隐私，有些通信不能被其他人知道。互联网私人生活交流信息不被恶意者随意窃取，也应该是社会秩序正常稳定的表现，平时的通信不过如此，涉及到商业信息，数据保密更显得格外重要。加密算法是保持通信信息不泄漏的一种技术，可用手段。’’ 前言 网络数据加密是必须做的事 安全正确必要性 互联网通信通过电缆或者无线设备，信息是可以被中间人收到记录的，所以要考虑很多风险因素，信息必须被加密处理只是其中之一的考虑 信息安全 明文可能被第三方劫持查看。 就像写信一样，A写信给B，在信件到达B手上之前，信件在途中可能被别人拆开看过然后再封装原样，使AB都不能发觉信息已经被第三个人看了。 信息正确 传输信息可能被修改 同样A给B写信，在途中信件被人劫持，如果信件途中被别人打开，替换里面的信息内容，B收到后的信息很可能是错误的。 网络也是一样，网络通信必须通过有线或者无线设备传输，所以一定是可以劫持的，明文通信没有隐私可言，极不安全，所以加密算法通常需要做的事 概念 参考文章 https://www.cnblogs.com/hulianwangjiagoushi/p/10671771.html 首先加密是因为存在网路信息传输，所以加密的使用过程分三步 举例 A计算机通过网络传输信息给B计算机，中间使用加密算法过程如下 A (明文 –&gt;加密–&gt;密文) ———–网络（密文）———–&gt; B（密文 –&gt;解密–&gt;明文） st=&gt;start: 明文 op1=&gt;operation: A端加密 op2=&gt;operation: 加密密文网络传输 cond=&gt;condition: 签名确认 是否为A端发送的加密数据? op3=&gt;operation: B端解密 op4=&gt;operation: 丢弃（被篡改）信息 e=&gt;end: 明文 st-&gt;op1-&gt;op2-&gt;cond op3-&gt;e cond(yes)-&gt;op3-&gt;e cond(no)-&gt;op4 #cond=&gt;condition: Yes or No? #cond(yes)-&gt;e #cond(no)-&gt;op 密钥 用于加密的根据，明文加密成密文的凭据，根据密钥有规则的加密，也只有根据密钥才能有规则的解密，应此通信中加密的密钥保管也很重要（不能被泄露） 明文 明文指两者通信的原文，能看懂的。 加密 将明文通过某种方式加密变成密文 密文 将明文加密后的信息，并且除了密钥，不能用其他方式将其解密成原文信息 传输 密文的传输（不怕别人看到密文，密文看不到真实信息，第三方不能获取有效信息） 解密 将密文还原成明文（接收者能看到明文） 签名 保证双方的信息真实没被修改的技术 A与B之间要有一种签名存在，在通信的时候，收到信息，通过签名要能鉴别信息是否被第三方修改或者信息是第三方伪造发送。 加密算法 信息加密是非常专业的计算知识，通过复杂设计，对信息数据加密，使不能被轻易破解。常见的加密算法都需要有密钥，通过密钥分类又可以分为对称加密和非对称加密。 对称加密指信息的加密和解密使用同一个密钥，非对称加密则是信息的加密和解密不是用到同一个密钥 对称加密 AES 密码学中的高级加密标准（Advanced Encryption Standard，AES） 这个标准用来替代原先的DES（Data Encryption Standard），已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院 （NIST）于2001年11月26日发布于FIPS PUB 197，并在2002年5月26日成为有效的标准。2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一 [1] 。 该算法为比利时密码学家Joan Daemen和Vincent Rijmen所设计，结合两位作者的名字，以Rijdael之名命之，投稿高级加密标准的甄选流程。（Rijdael的发音近于 “Rhine doll”。） 原理 AES加密数据块和密钥长度可以是128b、192b、256b中的任意一个。AES加密有很多轮的重复和变换。大致步骤如下：①密钥扩展（Key Expansion)；②初始轮（InitialRound)；③重复轮（Rounds），每一重复轮又包括字节间减法运算（SubBytes）、行移位（ShiftRows）、列混合（MixColumns)、轮密钥加法运算（AddRoundKey)等操作；①最终轮（Final Round)，最终轮没有列混合操作（MixColumns)。 相关文章介绍： https://blog.csdn.net/zxh2075/article/details/80630296 https://www.jianshu.com/p/79a225c2650e https://blog.csdn.net/huangxiaoguo1/article/details/78043169 加密过程 128位密钥加密流程简略描述： st=&gt;start: 待加密明文 op0=&gt;operation: 明文与密钥异或运算 op1=&gt;operation: 获取加密密钥，设置填充方式 op2=&gt;operation: 加密（信息+密钥 规律运算） cond1=&gt;condition: 循环了9次？ op3=&gt;operation: 第十次加密运算（区别于前面9次） op4=&gt;operation: （明文+密钥）规律位运算调整 e=&gt;end: AES加密密文 st-&gt;op0-&gt;op2-&gt;cond1 op3-&gt;e cond1(yes)-&gt;op3 cond1(no)-&gt;op4-&gt;op2 解密（逆运算） 因为明文加密10轮是根据密钥有规律的复杂运算，因此解密就是上述过程的逆运算，只要有密钥，就能通过规律逆运算得到明文 加密模式 对称/分组密码一般分为流加密(如OFB、CFB等)和块加密(如ECB、CBC等)。对于流加密，需要将分组密码转化为流模式工作。对于块加密(或称分组加密)，如果要加密超过块大小的数据，就需要涉及填充和链加密模式。 ECB ECB(Electronic Code Book电子密码本)模式 ECB模式是最早采用和最简单的模式，它将加密的数据分成若干组，每组的大小跟加密密钥长度相同，然后每组都用相同的密钥进行加密。 CBC CBC(Cipher Block Chaining，加密块链)模式 这种模式是先将明文切分成若干小段，然后每一小段与初始块或者上一段的密文段进行异或运算后，再与密钥进行加密。 java使用AES加密 AesCrypto.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 package com.emoyc.note.common.util.encryption.aes; import javax.crypto.Cipher; import javax.crypto.KeyGenerator; import javax.crypto.spec.IvParameterSpec; import javax.crypto.spec.SecretKeySpec; /** * AES加密 * @author Narule * */ public class AesCrypto { /** * AES加密模式 */ private static final String ECB_MODE = &quot;AES/ECB/PKCS5Padding&quot;; private static final String CBC_MODE = &quot;AES/CBC/PKCS5Padding&quot;; /** * AES ECB模式加密 * @param content 待加密的内容 * @param encryptKey 加密密钥 * @return 加密后的byte[] * @throws Exception */ public static byte[] aesEncryptToBytes_ECB(byte[] contentBytes, byte[] keyBytes) throws Exception { KeyGenerator kgen = KeyGenerator.getInstance(&quot;AES&quot;); kgen.init(128); Cipher cipher = Cipher.getInstance(ECB_MODE); cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(keyBytes, &quot;AES&quot;)); return cipher.doFinal(contentBytes); } /** * AES ECB模式解密 * @param encryptBytes 待解密的byte[] * @param decryptKey 解密密钥 * @return 解密后的String * @throws Exception */ public static byte[] aesDecryptByBytes_ECB(byte[] encryptBytes, byte[] keyBytes) throws Exception { KeyGenerator kgen = KeyGenerator.getInstance(&quot;AES&quot;); kgen.init(128); Cipher cipher = Cipher.getInstance(ECB_MODE); cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(keyBytes, &quot;AES&quot;)); return cipher.doFinal(encryptBytes); } /** * AES CBC模式加密 * @throws Exception */ public static byte[] aesEncryptToBytes_CBC(byte[] encryptBytes, byte[] ivBytes,byte[] keyBytes) throws Exception { SecretKeySpec key = new SecretKeySpec(keyBytes, &quot;AES&quot;); IvParameterSpec IV = new IvParameterSpec(ivBytes); Cipher c = Cipher.getInstance(CBC_MODE); c.init(Cipher.ENCRYPT_MODE, key, IV); return c.doFinal(encryptBytes); } /** * AES CBC模式解密 * @throws Exception */ public static byte[] aesDecryptByBytes_CBC(byte[] decryptBytes, byte[] ivBytes,byte[] keyBytes) throws Exception { SecretKeySpec key = new SecretKeySpec(keyBytes, &quot;AES&quot;); IvParameterSpec IV = new IvParameterSpec(ivBytes); Cipher c = Cipher.getInstance(CBC_MODE); c.init(Cipher.DECRYPT_MODE, key, IV); return c.doFinal(decryptBytes); } } AesUtil.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 package com.emoyc.note.common.util.encryption.aes; /** * AES 加密整合工具类 * @author Narule * */ public class AesUtil { /** * AES临时KEY */ private static final String KEY = &quot;jdkcnvlao903nhfl&quot;; /** * AES-ECB 加密模式 * @param content //原文 * @param key * @return _encrypt //密文 * @throws Exception */ public final static String aesEncrypt_ECB(String content,String key) throws Exception { return base64Encode( AesCrypto.aesEncryptToBytes_ECB(content.getBytes(), key.getBytes()) ); } /** * AES-ECB 解密模式 * @param content //密文 * @param key * @return _decrypt //原文 * @throws Exception */ public final static String aesDecrypt_ECB(String content,String key) throws Exception { return new String( AesCrypto.aesDecryptByBytes_ECB(base64Decode(content), key.getBytes()) ); } /** * AES-CBC 加密模式 * @param content //原文 * @param key * @return _encrypt //密文 * @throws Exception */ public final static String aesEncrypt_CBC(String content,String key) throws Exception { return base64Encode( AesCrypto.aesEncryptToBytes_CBC(content.getBytes(), key.getBytes(),key.getBytes()) ); } /** * AES-CBC 解密模式 * @param content //密文 * @param key * @return _decrypt //原文 * @throws Exception */ public final static String aesDecrypt_CBC(String content,String key) throws Exception { return new String( AesCrypto.aesDecryptByBytes_CBC(base64Decode(content), key.getBytes(), key.getBytes()) ); } /** * base 64 encode * @param bytes 待编码的byte[] * @return 编码后的base 64 code */ public static String base64Encode(byte[] bytes){ return java.util.Base64.getEncoder().encodeToString(bytes); } /** * base 64 decode * @param base64Code 待解码的base 64 code * @return 解码后的byte[] * @throws Exception */ public static byte[] base64Decode(String base64Code) throws Exception{ return (base64Code == null || base64Code.length() == 0) ? null : java.util.Base64.getDecoder().decode(base64Code); } public static void main(String[] args) { String string = &quot;吴楠予&quot;; testAes_ECB(string); testAes_CBC(string); } private static void testAes_ECB(String string) { System.out.println(&quot;===================ECB加密=================&quot;); System.out.println(&quot;明文：&quot; ); System.out.println(string); String aesEncrypt_ECB = null; String aesDecrypt_ECB = null; try { aesEncrypt_ECB = aesEncrypt_ECB(string, KEY); System.out.println(&quot;密文：&quot;); System.out.println(aesEncrypt_ECB); aesDecrypt_ECB = aesDecrypt_ECB(aesEncrypt_ECB, KEY); System.out.println(&quot;解密后：&quot;); System.out.println(aesDecrypt_ECB); } catch (Exception e) { e.printStackTrace(); } } private static void testAes_CBC(String string) { System.out.println(&quot;===================CBC加密=================&quot;); System.out.println(&quot;明文：&quot; ); System.out.println(string); String aesEncrypt_CBC = null; String aesDecrypt_CBC = null; try { aesEncrypt_CBC = aesEncrypt_CBC(string, KEY); System.out.println(&quot;密文：&quot;); System.out.println(aesEncrypt_CBC); aesDecrypt_CBC = aesDecrypt_CBC(aesEncrypt_CBC, KEY); System.out.println(&quot;解密后：&quot;); System.out.println(aesDecrypt_CBC); } catch (Exception e) { e.printStackTrace(); } } } 加解密Test 运行AesUtil的main方法： 非对称加密 RSA 参考文章 http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html https://www.jianshu.com/p/ca659dbc6f46 通过上面的文章自己实践测试，数字小，但是不影响 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 p = 3 q = 5 n = 3 * 5 = 15 n&#39; = 2 * 4 = 8 选一个数 e 与 8 互质 e = 7 7 * x + 8 * y = 1 x = 7 = d y = -6 加密 3 3^7 = 2187 2187%15 = 12 12^7%15 = 3 e = ３ 3 * x + 8 * y = 1 x = 11 = d y = -4 加密 3 3^3 = 27 27%15 = 12 12^11%15 = 3 java使用RSA加密工具 RsaUtil.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 package com.emoyc.note.common.util.encryption.rsa; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.InputStream; import java.io.OutputStream; import java.security.KeyPair; /** * RSA 加密工具整合类 * @author Narule * */ public class RsaUtil { private static byte[] publicKey; private static byte[] privateKey; /** * main方法 - RSA 加密解密测试 * @param args * @throws Exception */ public static void main(String[] args) throws Exception { createKey(); initKey(); String str = &quot;吴楠予&quot;; byte[] encryptData = RsaCrypto.encryptData(str.getBytes(), publicKey); System.out.println(&quot;=========加密===============&quot;); System.out.println(new String(encryptData)); System.out.println(&quot;=========解密===============&quot;); byte[] decryptData = RsaCrypto.decryptData(encryptData, privateKey); System.out.println(new String(decryptData)); } /** * createKey 创建RSA 密钥对 */ private static void createKey() { try { KeyPair generateKeyPair = RsaCrypto.creatKey(); byteToFile(generateKeyPair.getPublic().getEncoded(), &quot;./rsa_2048_pubkey.txt&quot;); byteToFile(generateKeyPair.getPrivate().getEncoded(), &quot;./rsa_2048_prikey.txt&quot;); } catch (Exception e) { e.printStackTrace(); } } public static KeyPair getOneRsaKey() { try { return RsaCrypto.creatKey(); } catch (Exception e) { e.printStackTrace(); } return null; } /** * readKey 读取密钥文件 */ private static void initKey() { try { publicKey = fileToByte(&quot;./rsa_2048_pubkey.txt&quot;); privateKey = fileToByte(&quot;./rsa_2048_prikey.txt&quot;); } catch (Exception e) { e.printStackTrace(); } } /** * byte-&gt;file 二进制数据转文件 * @param bytes * @param filePath * @throws Exception */ public static void byteToFile(byte[] bytes, String filePath) throws Exception { InputStream in = new ByteArrayInputStream(bytes); File destFile = new File(filePath); if (!destFile.getParentFile().exists()) { destFile.getParentFile().mkdirs(); } destFile.createNewFile(); OutputStream out = new FileOutputStream(destFile); byte[] cache = new byte[2048]; int nRead = 0; while ((nRead = in.read(cache)) != -1) { out.write(cache, 0, nRead); out.flush(); } out.close(); in.close(); } /** * file-&gt;byte 文件转二进制 * @param filePath * @return * @throws Exception */ public static byte[] fileToByte(String filePath) throws Exception { byte[] data = new byte[0]; File file = new File(filePath); if (file.exists()) { FileInputStream in = new FileInputStream(file); ByteArrayOutputStream out = new ByteArrayOutputStream(2048); byte[] cache = new byte[2048]; int nRead = 0; while ((nRead = in.read(cache)) != -1) { out.write(cache, 0, nRead); out.flush(); } out.close(); in.close(); data = out.toByteArray(); } return data; } } RsaCrypto.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 package com.emoyc.note.common.util.encryption.rsa; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.security.Key; import java.security.KeyFactory; import java.security.KeyPair; import java.security.KeyPairGenerator; import java.security.PublicKey; import java.security.spec.PKCS8EncodedKeySpec; import java.security.spec.X509EncodedKeySpec; import javax.crypto.Cipher; /** * RSA 加密解密类 * @author Narule * */ public class RsaCrypto { private static final String ALGORITHM_RSA = &quot;RSA&quot;; /** */ /** * RSA最大加密明文大小 */ // 2048 private static final int MAX_ENCRYPT_BLOCK = 245; /** */ /** * RSA最大解密密文大小 */ // 2048 private static final int MAX_DECRYPT_BLOCK = 256; public static KeyPair creatKey() throws Exception { KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(ALGORITHM_RSA); keyPairGenerator.initialize(2048); return keyPairGenerator.generateKeyPair(); } /** * RSA 公钥加密 * * @param data * @param key * @return * @throws Exception */ public static byte[] encryptData(byte[] data, byte[] key) { ByteArrayOutputStream out = null; byte[] encryptedData = null; try { X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(key); KeyFactory keyFactory = KeyFactory.getInstance(ALGORITHM_RSA); PublicKey generatePublic = keyFactory.generatePublic(x509KeySpec); // 对数据加密 Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(Cipher.ENCRYPT_MODE, generatePublic); int inputLen = data.length; out = new ByteArrayOutputStream(); int offSet = 0; byte[] cache; int i = 0; // 对数据分段加密 while (inputLen - offSet &gt; 0) { if (inputLen - offSet &gt; MAX_ENCRYPT_BLOCK) { cache = cipher.doFinal(data, offSet, MAX_ENCRYPT_BLOCK); } else { cache = cipher.doFinal(data, offSet, inputLen - offSet); } out.write(cache, 0, cache.length); i++; offSet = i * MAX_ENCRYPT_BLOCK; } encryptedData = out.toByteArray(); out.close(); } catch (Exception e) { e.printStackTrace(); } finally { // 防止流未关闭 浪费占用资源 if (out != null) { try { out.close(); } catch (IOException e) { e.printStackTrace(); } } } return encryptedData; } /** * RSA 私钥解密 * * @param data * @param key * @return * @throws Exception */ public static byte[] decryptData(byte[] data, byte[] key) { ByteArrayOutputStream out = null; byte[] decryptedData = null; try { PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(key); KeyFactory keyFactory = KeyFactory.getInstance(ALGORITHM_RSA); Key privateK = keyFactory.generatePrivate(pkcs8KeySpec); Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(Cipher.DECRYPT_MODE, privateK); out = new ByteArrayOutputStream(); int inputLen = data.length; int offSet = 0; byte[] cache; int i = 0; // 对数据分段解密 while (inputLen - offSet &gt; 0) { if (inputLen - offSet &gt; MAX_DECRYPT_BLOCK) { cache = cipher.doFinal(data, offSet, MAX_DECRYPT_BLOCK); } else { cache = cipher.doFinal(data, offSet, inputLen - offSet); } out.write(cache, 0, cache.length); i++; offSet = i * MAX_DECRYPT_BLOCK; } decryptedData = out.toByteArray(); out.close(); } catch (Exception e) { e.printStackTrace(); } finally { // 防止流未关闭 浪费占用资源 if (out != null) { try { out.close(); } catch (IOException e) { e.printStackTrace(); } } } return decryptedData; } } 其他","headline":"数据加密","dateModified":"2021-02-03T04:22:50+08:00","datePublished":"2020-05-22T23:10:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://narule.github.io/posts/%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/"},"url":"https://narule.github.io/posts/%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/","author":{"@type":"Person","name":"Narule"},"@type":"BlogPosting","@context":"https://schema.org"}</script><title>数据加密 | Narule</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="preload" href="/assets/css/post.css" as="style"><link rel="stylesheet" href="/assets/css/post.css"><link rel="preload" as="style" href="/assets/css/lib/bootstrap-toc.min.css"><link rel="stylesheet" href="/assets/css/lib/bootstrap-toc.min.css" /> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="/assets/js/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-JVHJ82NYZT"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-JVHJ82NYZT'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://narule.github.io/avatar.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Narule</a></div><div class="site-subtitle font-italic">A Blog for Article; Chinese Blog is www.cnblogs.com/narule</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tabs/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tabs/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/tabs/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/tabs/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/narule" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/no_twitter" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['narule','163.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>数据加密</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>数据加密</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Fri, May 22, 2020, 11:10 PM +0800" > May 22, 2020 <i class="unloaded">2020-05-22T23:10:00+08:00</i> </span> by <span class="author"> Narule </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Wed, Feb 3, 2021, 4:22 AM +0800" > Feb 3, 2021 <i class="unloaded">2021-02-03T04:22:50+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3890 words">21 min</span></div></div><div class="post-content"><h1 id="网络数据加密">网络数据加密</h1><p>互联网，将全球不同的计算机等电子设备连接起来，使具备互相通信的条件，但是通信信息有些事隐私，有些通信不能被其他人知道。互联网私人生活交流信息不被恶意者随意窃取，也应该是社会秩序正常稳定的表现，平时的通信不过如此，涉及到商业信息，数据保密更显得格外重要。加密算法是保持通信信息不泄漏的一种技术，可用手段。’’</p><h2 id="前言">前言</h2><h3 id="网络数据加密是必须做的事">网络数据加密是必须做的事</h3><h4 id="安全正确必要性">安全正确必要性</h4><p>互联网通信通过电缆或者无线设备，信息是可以被中间人收到记录的，所以要考虑很多风险因素，信息必须被加密处理只是其中之一的考虑</p><h5 id="信息安全">信息安全</h5><p>明文可能被第三方劫持查看。</p><p>就像写信一样，A写信给B，在信件到达B手上之前，信件在途中可能被别人拆开看过然后再封装原样，使AB都不能发觉信息已经被第三个人看了。</p><h5 id="信息正确">信息正确</h5><p>传输信息可能被修改</p><p>同样A给B写信，在途中信件被人劫持，如果信件途中被别人打开，替换里面的信息内容，B收到后的信息很可能是错误的。</p><p>网络也是一样，网络通信必须通过有线或者无线设备传输，所以一定是可以劫持的，明文通信没有隐私可言，极不安全，所以加密算法通常需要做的事</p><h2 id="概念">概念</h2><blockquote><p>参考文章</p><p>https://www.cnblogs.com/hulianwangjiagoushi/p/10671771.html</p></blockquote><p>首先加密是因为存在网路信息传输，所以加密的使用过程分三步</p><p>举例 A计算机通过网络传输信息给B计算机，中间使用加密算法过程如下</p><p>A (明文 –&gt;加密–&gt;密文) ———–网络（密文）———–&gt; B（密文 –&gt;解密–&gt;明文）</p><pre><code class="language-flow">st=&gt;start: 明文
op1=&gt;operation: A端加密
op2=&gt;operation: 加密密文网络传输
cond=&gt;condition: 签名确认 是否为A端发送的加密数据?
op3=&gt;operation: B端解密
op4=&gt;operation: 丢弃（被篡改）信息
e=&gt;end: 明文
st-&gt;op1-&gt;op2-&gt;cond
op3-&gt;e
cond(yes)-&gt;op3-&gt;e
cond(no)-&gt;op4

#cond=&gt;condition: Yes or No?
#cond(yes)-&gt;e
#cond(no)-&gt;op
</code></pre><h5 id="密钥">密钥</h5><p>用于加密的根据，明文加密成密文的凭据，根据密钥有规则的加密，也只有根据密钥才能有规则的解密，应此通信中加密的密钥保管也很重要（不能被泄露）</p><h5 id="明文">明文</h5><p>明文指两者通信的原文，能看懂的。</p><h5 id="加密">加密</h5><p>将明文通过某种方式加密变成密文</p><h5 id="密文">密文</h5><p>将明文加密后的信息，并且除了密钥，不能用其他方式将其解密成原文信息</p><h5 id="传输">传输</h5><p>密文的传输（不怕别人看到密文，密文看不到真实信息，第三方不能获取有效信息）</p><h5 id="解密">解密</h5><p>将密文还原成明文（接收者能看到明文）</p><h5 id="签名">签名</h5><p>保证双方的信息真实没被修改的技术</p><p>A与B之间要有一种签名存在，在通信的时候，收到信息，通过签名要能鉴别信息是否被第三方修改或者信息是第三方伪造发送。</p><h1 id="加密算法">加密算法</h1><p>信息加密是非常专业的计算知识，通过复杂设计，对信息数据加密，使不能被轻易破解。常见的加密算法都需要有密钥，通过密钥分类又可以分为对称加密和非对称加密。</p><p>对称加密指信息的加密和解密使用同一个密钥，非对称加密则是信息的加密和解密不是用到同一个密钥</p><h2 id="对称加密">对称加密</h2><h3 id="aes">AES</h3><blockquote><p>密码学中的高级加密标准（Advanced Encryption Standard，AES）</p><p>这个标准用来替代原先的<a href="https://baike.baidu.com/item/DES">DES</a>（Data Encryption Standard），已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院 （NIST）于2001年11月26日发布于FIPS PUB 197，并在2002年5月26日成为有效的标准。2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一 [1] 。</p><p>该算法为比利时密码学家Joan Daemen和Vincent Rijmen所设计，结合两位作者的名字，以Rijdael之名命之，投稿高级加密标准的甄选流程。（Rijdael的发音近于 “Rhine doll”。）</p></blockquote><h4 id="原理">原理</h4><blockquote><p>AES加密数据块和密钥长度可以是128b、192b、256b中的任意一个。AES加密有很多轮的重复和变换。大致步骤如下：①密钥扩展（Key Expansion)；②初始轮（InitialRound)；③重复轮（Rounds），每一重复轮又包括字节间减法运算（SubBytes）、行移位（ShiftRows）、列混合（MixColumns)、轮密钥加法运算（AddRoundKey)等操作；①最终轮（Final Round)，最终轮没有列混合操作（MixColumns)。</p></blockquote><h5 id="相关文章介绍">相关文章介绍：</h5><p>https://blog.csdn.net/zxh2075/article/details/80630296</p><p>https://www.jianshu.com/p/79a225c2650e</p><p>https://blog.csdn.net/huangxiaoguo1/article/details/78043169</p><h4 id="加密过程">加密过程</h4><p>128位密钥加密流程简略描述：</p><pre><code class="language-flow">st=&gt;start: 待加密明文
op0=&gt;operation: 明文与密钥异或运算
op1=&gt;operation: 获取加密密钥，设置填充方式
op2=&gt;operation: 加密（信息+密钥 规律运算）
cond1=&gt;condition: 循环了9次？
op3=&gt;operation: 第十次加密运算（区别于前面9次）
op4=&gt;operation: （明文+密钥）规律位运算调整
e=&gt;end: AES加密密文

st-&gt;op0-&gt;op2-&gt;cond1
op3-&gt;e
cond1(yes)-&gt;op3
cond1(no)-&gt;op4-&gt;op2


</code></pre><h4 id="解密逆运算">解密（逆运算）</h4><p>因为明文加密10轮是根据密钥有规律的复杂运算，因此解密就是上述过程的逆运算，只要有密钥，就能通过规律逆运算得到明文</p><h4 id="加密模式">加密模式</h4><blockquote><p>对称/<a href="https://baike.baidu.com/item/分组密码">分组密码</a>一般分为流加密(如OFB、CFB等)和块加密(如ECB、CBC等)。对于流加密，需要将分组密码转化为流模式工作。对于块加密(或称分组加密)，如果要加密超过块大小的数据，就需要涉及填充和链加密模式。</p></blockquote><h5 id="ecb">ECB</h5><blockquote><p>ECB(Electronic Code Book电子密码本)模式</p><p>ECB模式是最早采用和最简单的模式，它将加密的数据分成若干组，每组的大小跟加密密钥长度相同，然后每组都用相同的密钥进行加密。</p></blockquote><h5 id="cbc">CBC</h5><blockquote><p>CBC(Cipher Block Chaining，加密块链)模式</p><p>这种模式是先将明文切分成若干小段，然后每一小段与初始块或者上一段的密文段进行异或运算后，再与密钥进行加密。</p></blockquote><h4 id="java使用aes加密">java使用AES加密</h4><h5 id="aescryptojava">AesCrypto.java</h5><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
</pre><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">com.emoyc.note.common.util.encryption.aes</span><span class="o">;</span>


<span class="kn">import</span> <span class="nn">javax.crypto.Cipher</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.crypto.KeyGenerator</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.crypto.spec.IvParameterSpec</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.crypto.spec.SecretKeySpec</span><span class="o">;</span>

<span class="cm">/**
 * AES加密
 * @author Narule
 *
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AesCrypto</span> <span class="o">{</span>
	
	<span class="cm">/**
	 * AES加密模式
	 */</span>
	
	<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">ECB_MODE</span> <span class="o">=</span> <span class="s">"AES/ECB/PKCS5Padding"</span><span class="o">;</span>

	<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">CBC_MODE</span> <span class="o">=</span> <span class="s">"AES/CBC/PKCS5Padding"</span><span class="o">;</span>
	
	
	<span class="cm">/**
	 * AES ECB模式加密
     * @param content 待加密的内容 
     * @param encryptKey 加密密钥 
     * @return 加密后的byte[] 
     * @throws Exception 
     */</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">aesEncryptToBytes_ECB</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">contentBytes</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">keyBytes</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>  
        <span class="nc">KeyGenerator</span> <span class="n">kgen</span> <span class="o">=</span> <span class="nc">KeyGenerator</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"AES"</span><span class="o">);</span>  
        <span class="n">kgen</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="mi">128</span><span class="o">);</span>  
        <span class="nc">Cipher</span> <span class="n">cipher</span> <span class="o">=</span> <span class="nc">Cipher</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="no">ECB_MODE</span><span class="o">);</span>  
        <span class="n">cipher</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="nc">Cipher</span><span class="o">.</span><span class="na">ENCRYPT_MODE</span><span class="o">,</span> <span class="k">new</span> <span class="nc">SecretKeySpec</span><span class="o">(</span><span class="n">keyBytes</span><span class="o">,</span> <span class="s">"AES"</span><span class="o">));</span>  
        <span class="k">return</span> <span class="n">cipher</span><span class="o">.</span><span class="na">doFinal</span><span class="o">(</span><span class="n">contentBytes</span><span class="o">);</span>
    <span class="o">}</span> 
	
	<span class="cm">/**
	 * AES ECB模式解密
	 * @param encryptBytes 待解密的byte[] 
     * @param decryptKey 解密密钥 
     * @return 解密后的String 
     * @throws Exception 
     */</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">aesDecryptByBytes_ECB</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">encryptBytes</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">keyBytes</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>  
        <span class="nc">KeyGenerator</span> <span class="n">kgen</span> <span class="o">=</span> <span class="nc">KeyGenerator</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"AES"</span><span class="o">);</span>  
        <span class="n">kgen</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="mi">128</span><span class="o">);</span>
        <span class="nc">Cipher</span> <span class="n">cipher</span> <span class="o">=</span> <span class="nc">Cipher</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="no">ECB_MODE</span><span class="o">);</span>  
        <span class="n">cipher</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="nc">Cipher</span><span class="o">.</span><span class="na">DECRYPT_MODE</span><span class="o">,</span> <span class="k">new</span> <span class="nc">SecretKeySpec</span><span class="o">(</span><span class="n">keyBytes</span><span class="o">,</span> <span class="s">"AES"</span><span class="o">));</span>  
        <span class="k">return</span> <span class="n">cipher</span><span class="o">.</span><span class="na">doFinal</span><span class="o">(</span><span class="n">encryptBytes</span><span class="o">);</span>
    <span class="o">}</span>  
	
    
	
	<span class="cm">/**
	 * AES CBC模式加密
	 * @throws Exception 
	 */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">aesEncryptToBytes_CBC</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">encryptBytes</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">ivBytes</span><span class="o">,</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">keyBytes</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
		<span class="nc">SecretKeySpec</span> <span class="n">key</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SecretKeySpec</span><span class="o">(</span><span class="n">keyBytes</span><span class="o">,</span> <span class="s">"AES"</span><span class="o">);</span>
		<span class="nc">IvParameterSpec</span> <span class="no">IV</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">IvParameterSpec</span><span class="o">(</span><span class="n">ivBytes</span><span class="o">);</span>
		<span class="nc">Cipher</span> <span class="n">c</span> <span class="o">=</span> <span class="nc">Cipher</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="no">CBC_MODE</span><span class="o">);</span>
		<span class="n">c</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="nc">Cipher</span><span class="o">.</span><span class="na">ENCRYPT_MODE</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="no">IV</span><span class="o">);</span>
		<span class="k">return</span> <span class="n">c</span><span class="o">.</span><span class="na">doFinal</span><span class="o">(</span><span class="n">encryptBytes</span><span class="o">);</span>
	<span class="o">}</span>
	
	<span class="cm">/**
	 * AES CBC模式解密
	 * @throws Exception 
	 */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">aesDecryptByBytes_CBC</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">decryptBytes</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">ivBytes</span><span class="o">,</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">keyBytes</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>  
    	<span class="nc">SecretKeySpec</span> <span class="n">key</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SecretKeySpec</span><span class="o">(</span><span class="n">keyBytes</span><span class="o">,</span> <span class="s">"AES"</span><span class="o">);</span>
		<span class="nc">IvParameterSpec</span> <span class="no">IV</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">IvParameterSpec</span><span class="o">(</span><span class="n">ivBytes</span><span class="o">);</span>
    	<span class="nc">Cipher</span> <span class="n">c</span> <span class="o">=</span> <span class="nc">Cipher</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="no">CBC_MODE</span><span class="o">);</span>
        <span class="n">c</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="nc">Cipher</span><span class="o">.</span><span class="na">DECRYPT_MODE</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="no">IV</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">c</span><span class="o">.</span><span class="na">doFinal</span><span class="o">(</span><span class="n">decryptBytes</span><span class="o">);</span> 
    <span class="o">}</span> 
    
<span class="o">}</span>

</pre></table></code></div></div><h5 id="aesutiljava">AesUtil.java</h5><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
</pre><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">com.emoyc.note.common.util.encryption.aes</span><span class="o">;</span>


<span class="cm">/**
 * AES 加密整合工具类
 * @author Narule
 *
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AesUtil</span> <span class="o">{</span>
	
	<span class="cm">/**
	 * AES临时KEY
	 */</span>
	<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">KEY</span> <span class="o">=</span> <span class="s">"jdkcnvlao903nhfl"</span><span class="o">;</span>
	
	
	<span class="cm">/**
	 * AES-ECB 加密模式
	 * @param content //原文
	 * @param key
	 * @return _encrypt //密文
	 * @throws Exception
	 */</span>
	<span class="kd">public</span> <span class="kd">final</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">aesEncrypt_ECB</span><span class="o">(</span><span class="nc">String</span> <span class="n">content</span><span class="o">,</span><span class="nc">String</span> <span class="n">key</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
		<span class="k">return</span> <span class="nf">base64Encode</span><span class="o">(</span>
					<span class="nc">AesCrypto</span><span class="o">.</span><span class="na">aesEncryptToBytes_ECB</span><span class="o">(</span><span class="n">content</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(),</span> <span class="n">key</span><span class="o">.</span><span class="na">getBytes</span><span class="o">())</span>
				<span class="o">);</span>
	<span class="o">}</span>
	
	<span class="cm">/**
	 * AES-ECB 解密模式
	 * @param content //密文
	 * @param key
	 * @return _decrypt //原文
	 * @throws Exception
	 */</span>
	<span class="kd">public</span> <span class="kd">final</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">aesDecrypt_ECB</span><span class="o">(</span><span class="nc">String</span> <span class="n">content</span><span class="o">,</span><span class="nc">String</span> <span class="n">key</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
		<span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span>
					<span class="nc">AesCrypto</span><span class="o">.</span><span class="na">aesDecryptByBytes_ECB</span><span class="o">(</span><span class="n">base64Decode</span><span class="o">(</span><span class="n">content</span><span class="o">),</span> <span class="n">key</span><span class="o">.</span><span class="na">getBytes</span><span class="o">())</span>
				<span class="o">);</span>
	<span class="o">}</span>
	
	<span class="cm">/**
	 * AES-CBC 加密模式
	 * @param content //原文
	 * @param key
	 * @return _encrypt //密文
	 * @throws Exception
	 */</span>
	<span class="kd">public</span> <span class="kd">final</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">aesEncrypt_CBC</span><span class="o">(</span><span class="nc">String</span> <span class="n">content</span><span class="o">,</span><span class="nc">String</span> <span class="n">key</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
		
		<span class="k">return</span> <span class="nf">base64Encode</span><span class="o">(</span>
					<span class="nc">AesCrypto</span><span class="o">.</span><span class="na">aesEncryptToBytes_CBC</span><span class="o">(</span><span class="n">content</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(),</span> <span class="n">key</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(),</span><span class="n">key</span><span class="o">.</span><span class="na">getBytes</span><span class="o">())</span>
				<span class="o">);</span>
	<span class="o">}</span>
	
	<span class="cm">/**
	 * AES-CBC 解密模式
	 * @param content //密文
	 * @param key
	 * @return _decrypt //原文
	 * @throws Exception
	 */</span>
	<span class="kd">public</span> <span class="kd">final</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">aesDecrypt_CBC</span><span class="o">(</span><span class="nc">String</span> <span class="n">content</span><span class="o">,</span><span class="nc">String</span> <span class="n">key</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
		<span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span>
					<span class="nc">AesCrypto</span><span class="o">.</span><span class="na">aesDecryptByBytes_CBC</span><span class="o">(</span><span class="n">base64Decode</span><span class="o">(</span><span class="n">content</span><span class="o">),</span> <span class="n">key</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(),</span> <span class="n">key</span><span class="o">.</span><span class="na">getBytes</span><span class="o">())</span>
				<span class="o">);</span>
	<span class="o">}</span>
	
	
	 <span class="cm">/** 
     * base 64 encode 
     * @param bytes 待编码的byte[] 
     * @return 编码后的base 64 code 
     */</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">base64Encode</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">bytes</span><span class="o">){</span>  
    	<span class="k">return</span> <span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">Base64</span><span class="o">.</span><span class="na">getEncoder</span><span class="o">().</span><span class="na">encodeToString</span><span class="o">(</span><span class="n">bytes</span><span class="o">);</span>
    <span class="o">}</span>  
  
    <span class="cm">/** 
     * base 64 decode 
     * @param base64Code 待解码的base 64 code 
     * @return 解码后的byte[] 
     * @throws Exception 
     */</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">base64Decode</span><span class="o">(</span><span class="nc">String</span> <span class="n">base64Code</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span><span class="o">{</span>  
    	 <span class="k">return</span> <span class="o">(</span><span class="n">base64Code</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">base64Code</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">Base64</span><span class="o">.</span><span class="na">getDecoder</span><span class="o">().</span><span class="na">decode</span><span class="o">(</span><span class="n">base64Code</span><span class="o">);</span>
    <span class="o">}</span>
    
    
    
    
    
    
    
    
    
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    	<span class="nc">String</span> <span class="n">string</span> <span class="o">=</span> <span class="s">"吴楠予"</span><span class="o">;</span>
		<span class="n">testAes_ECB</span><span class="o">(</span><span class="n">string</span><span class="o">);</span>
		<span class="n">testAes_CBC</span><span class="o">(</span><span class="n">string</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">testAes_ECB</span><span class="o">(</span><span class="nc">String</span> <span class="n">string</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"===================ECB加密================="</span><span class="o">);</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"明文："</span> <span class="o">);</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">string</span><span class="o">);</span>
		<span class="nc">String</span> <span class="n">aesEncrypt_ECB</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
		<span class="nc">String</span> <span class="n">aesDecrypt_ECB</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
		<span class="k">try</span> <span class="o">{</span>
			<span class="n">aesEncrypt_ECB</span> <span class="o">=</span> <span class="n">aesEncrypt_ECB</span><span class="o">(</span><span class="n">string</span><span class="o">,</span> <span class="no">KEY</span><span class="o">);</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"密文："</span><span class="o">);</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">aesEncrypt_ECB</span><span class="o">);</span>
			<span class="n">aesDecrypt_ECB</span> <span class="o">=</span> <span class="n">aesDecrypt_ECB</span><span class="o">(</span><span class="n">aesEncrypt_ECB</span><span class="o">,</span> <span class="no">KEY</span><span class="o">);</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"解密后："</span><span class="o">);</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">aesDecrypt_ECB</span><span class="o">);</span>
		<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
		<span class="o">}</span>
	<span class="o">}</span>

	<span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">testAes_CBC</span><span class="o">(</span><span class="nc">String</span> <span class="n">string</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"===================CBC加密================="</span><span class="o">);</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"明文："</span> <span class="o">);</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">string</span><span class="o">);</span>
		<span class="nc">String</span> <span class="n">aesEncrypt_CBC</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
		<span class="nc">String</span> <span class="n">aesDecrypt_CBC</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
		<span class="k">try</span> <span class="o">{</span>
			<span class="n">aesEncrypt_CBC</span> <span class="o">=</span> <span class="n">aesEncrypt_CBC</span><span class="o">(</span><span class="n">string</span><span class="o">,</span> <span class="no">KEY</span><span class="o">);</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"密文："</span><span class="o">);</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">aesEncrypt_CBC</span><span class="o">);</span>
			<span class="n">aesDecrypt_CBC</span> <span class="o">=</span> <span class="n">aesDecrypt_CBC</span><span class="o">(</span><span class="n">aesEncrypt_CBC</span><span class="o">,</span> <span class="no">KEY</span><span class="o">);</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"解密后："</span><span class="o">);</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">aesDecrypt_CBC</span><span class="o">);</span>
		<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
		<span class="o">}</span>
	<span class="o">}</span> 
    
<span class="o">}</span>
</pre></table></code></div></div><h5 id="加解密test">加解密Test</h5><p>运行AesUtil的main方法：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://img2020.cnblogs.com/blog/1436620/202005/1436620-20200522141411759-2056476981.png" alt="" /></p><h2 id="非对称加密">非对称加密</h2><h3 id="rsa">RSA</h3><blockquote><p>参考文章</p><p>http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html</p><p>http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html</p><p>https://www.jianshu.com/p/ca659dbc6f46</p></blockquote><p>通过上面的文章自己实践测试，数字小，但是不影响</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre>
p = 3 q = 5

n = 3 * 5 = 15

n' = 2 * 4 = 8

选一个数 e  与 8 互质 
e = 7

7 * x + 8 * y = 1

x = 7 = d
y = -6


加密 3

3^7 = 2187

2187%15  = 12

12^7%15 = 3



e = ３

3 * x + 8 * y = 1

x = 11 = d
y = -4


加密 3

3^3 = 27

27%15  = 12

12^11%15 = 3
</pre></table></code></div></div><h4 id="java使用rsa加密工具">java使用RSA加密工具</h4><h5 id="rsautiljava">RsaUtil.java</h5><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
</pre><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">com.emoyc.note.common.util.encryption.rsa</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.io.ByteArrayInputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.ByteArrayOutputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.File</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.FileInputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.FileOutputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.InputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.OutputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.KeyPair</span><span class="o">;</span>

<span class="cm">/**
 * RSA 加密工具整合类
 * @author Narule
 *
 */</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RsaUtil</span> <span class="o">{</span>
	
	<span class="kd">private</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">publicKey</span><span class="o">;</span>
	<span class="kd">private</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">privateKey</span><span class="o">;</span>

	<span class="cm">/**
	 * main方法 - RSA 加密解密测试
	 * @param args
	 * @throws Exception
	 */</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
		<span class="n">createKey</span><span class="o">();</span>
		<span class="n">initKey</span><span class="o">();</span>
		<span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"吴楠予"</span><span class="o">;</span>
		<span class="kt">byte</span><span class="o">[]</span> <span class="n">encryptData</span> <span class="o">=</span> <span class="nc">RsaCrypto</span><span class="o">.</span><span class="na">encryptData</span><span class="o">(</span><span class="n">str</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(),</span> <span class="n">publicKey</span><span class="o">);</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"=========加密==============="</span><span class="o">);</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">encryptData</span><span class="o">));</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"=========解密==============="</span><span class="o">);</span>
		<span class="kt">byte</span><span class="o">[]</span> <span class="n">decryptData</span> <span class="o">=</span> <span class="nc">RsaCrypto</span><span class="o">.</span><span class="na">decryptData</span><span class="o">(</span><span class="n">encryptData</span><span class="o">,</span> <span class="n">privateKey</span><span class="o">);</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">decryptData</span><span class="o">));</span>
	<span class="o">}</span>
	
	<span class="cm">/**
	 * createKey 创建RSA 密钥对
	 */</span>
	<span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">createKey</span><span class="o">()</span> <span class="o">{</span>
    	<span class="k">try</span> <span class="o">{</span>
    		<span class="nc">KeyPair</span> <span class="n">generateKeyPair</span> <span class="o">=</span> <span class="nc">RsaCrypto</span><span class="o">.</span><span class="na">creatKey</span><span class="o">();</span>
    		<span class="n">byteToFile</span><span class="o">(</span><span class="n">generateKeyPair</span><span class="o">.</span><span class="na">getPublic</span><span class="o">().</span><span class="na">getEncoded</span><span class="o">(),</span> <span class="s">"./rsa_2048_pubkey.txt"</span><span class="o">);</span>
    		<span class="n">byteToFile</span><span class="o">(</span><span class="n">generateKeyPair</span><span class="o">.</span><span class="na">getPrivate</span><span class="o">().</span><span class="na">getEncoded</span><span class="o">(),</span> <span class="s">"./rsa_2048_prikey.txt"</span><span class="o">);</span>
    	<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    		<span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    	<span class="o">}</span>
    <span class="o">}</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="nc">KeyPair</span> <span class="nf">getOneRsaKey</span><span class="o">()</span> <span class="o">{</span>
    	<span class="k">try</span> <span class="o">{</span>
    		<span class="k">return</span> <span class="nc">RsaCrypto</span><span class="o">.</span><span class="na">creatKey</span><span class="o">();</span>
    	<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    		<span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    	<span class="o">}</span>
    	<span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
	<span class="cm">/**
	 * readKey 读取密钥文件
	 */</span>
	<span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">initKey</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">try</span> <span class="o">{</span>
			<span class="n">publicKey</span> <span class="o">=</span>  <span class="n">fileToByte</span><span class="o">(</span><span class="s">"./rsa_2048_pubkey.txt"</span><span class="o">);</span>
			<span class="n">privateKey</span> <span class="o">=</span>  <span class="n">fileToByte</span><span class="o">(</span><span class="s">"./rsa_2048_prikey.txt"</span><span class="o">);</span>
		<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
		<span class="o">}</span>
	<span class="o">}</span>
    
    
    
    <span class="cm">/**
     * byte-&gt;file 二进制数据转文件
     * @param bytes
     * @param filePath
     * @throws Exception
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">byteToFile</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">bytes</span><span class="o">,</span> <span class="nc">String</span> <span class="n">filePath</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">InputStream</span> <span class="n">in</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ByteArrayInputStream</span><span class="o">(</span><span class="n">bytes</span><span class="o">);</span>
        <span class="nc">File</span> <span class="n">destFile</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="n">filePath</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">destFile</span><span class="o">.</span><span class="na">getParentFile</span><span class="o">().</span><span class="na">exists</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">destFile</span><span class="o">.</span><span class="na">getParentFile</span><span class="o">().</span><span class="na">mkdirs</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="n">destFile</span><span class="o">.</span><span class="na">createNewFile</span><span class="o">();</span>
        <span class="nc">OutputStream</span> <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="n">destFile</span><span class="o">);</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">cache</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">2048</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">nRead</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">((</span><span class="n">nRead</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">cache</span><span class="o">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">out</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">cache</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">nRead</span><span class="o">);</span>
            <span class="n">out</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="n">out</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">in</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
    
    
    <span class="cm">/**
     * file-&gt;byte 文件转二进制
     * @param filePath
     * @return
     * @throws Exception
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">fileToByte</span><span class="o">(</span><span class="nc">String</span> <span class="n">filePath</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="nc">File</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="n">filePath</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">exists</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">FileInputStream</span> <span class="n">in</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="n">file</span><span class="o">);</span>
            <span class="nc">ByteArrayOutputStream</span> <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ByteArrayOutputStream</span><span class="o">(</span><span class="mi">2048</span><span class="o">);</span>
            <span class="kt">byte</span><span class="o">[]</span> <span class="n">cache</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">2048</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">nRead</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">while</span> <span class="o">((</span><span class="n">nRead</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">cache</span><span class="o">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">out</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">cache</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">nRead</span><span class="o">);</span>
                <span class="n">out</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="n">out</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
            <span class="n">in</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="na">toByteArray</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">data</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</pre></table></code></div></div><h5 id="rsacryptojava">RsaCrypto.java</h5><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
</pre><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">com.emoyc.note.common.util.encryption.rsa</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.io.ByteArrayOutputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.Key</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.KeyFactory</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.KeyPair</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.KeyPairGenerator</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.PublicKey</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.spec.PKCS8EncodedKeySpec</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.spec.X509EncodedKeySpec</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.crypto.Cipher</span><span class="o">;</span>


<span class="cm">/**
 * RSA 加密解密类
 * @author Narule
 *
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RsaCrypto</span> <span class="o">{</span>

	<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">ALGORITHM_RSA</span> <span class="o">=</span> <span class="s">"RSA"</span><span class="o">;</span>

	<span class="cm">/** */</span>
	<span class="cm">/**
	 * RSA最大加密明文大小
	 */</span>
	<span class="c1">// 2048</span>
	<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">MAX_ENCRYPT_BLOCK</span> <span class="o">=</span> <span class="mi">245</span><span class="o">;</span>

	<span class="cm">/** */</span>
	<span class="cm">/**
	 * RSA最大解密密文大小
	 */</span>
	<span class="c1">// 2048</span>
	<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">MAX_DECRYPT_BLOCK</span> <span class="o">=</span> <span class="mi">256</span><span class="o">;</span>


	
	<span class="kd">public</span> <span class="kd">static</span> <span class="nc">KeyPair</span> <span class="nf">creatKey</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
		<span class="nc">KeyPairGenerator</span> <span class="n">keyPairGenerator</span> <span class="o">=</span> <span class="nc">KeyPairGenerator</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="no">ALGORITHM_RSA</span><span class="o">);</span>
		<span class="n">keyPairGenerator</span><span class="o">.</span><span class="na">initialize</span><span class="o">(</span><span class="mi">2048</span><span class="o">);</span>
		<span class="k">return</span> <span class="n">keyPairGenerator</span><span class="o">.</span><span class="na">generateKeyPair</span><span class="o">();</span>
	<span class="o">}</span>
	
	
	<span class="cm">/**
	 * RSA 公钥加密
	 * 
	 * @param data
	 * @param key
	 * @return
	 * @throws Exception
	 */</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">encryptData</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">ByteArrayOutputStream</span> <span class="n">out</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
		<span class="kt">byte</span><span class="o">[]</span> <span class="n">encryptedData</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
		<span class="k">try</span> <span class="o">{</span>
			<span class="nc">X509EncodedKeySpec</span> <span class="n">x509KeySpec</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">X509EncodedKeySpec</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
			<span class="nc">KeyFactory</span> <span class="n">keyFactory</span> <span class="o">=</span> <span class="nc">KeyFactory</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="no">ALGORITHM_RSA</span><span class="o">);</span>
			<span class="nc">PublicKey</span> <span class="n">generatePublic</span> <span class="o">=</span> <span class="n">keyFactory</span><span class="o">.</span><span class="na">generatePublic</span><span class="o">(</span><span class="n">x509KeySpec</span><span class="o">);</span>

			<span class="c1">// 对数据加密</span>
			<span class="nc">Cipher</span> <span class="n">cipher</span> <span class="o">=</span> <span class="nc">Cipher</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">keyFactory</span><span class="o">.</span><span class="na">getAlgorithm</span><span class="o">());</span>
			<span class="n">cipher</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="nc">Cipher</span><span class="o">.</span><span class="na">ENCRYPT_MODE</span><span class="o">,</span> <span class="n">generatePublic</span><span class="o">);</span>
			<span class="kt">int</span> <span class="n">inputLen</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
			<span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ByteArrayOutputStream</span><span class="o">();</span>
			<span class="kt">int</span> <span class="n">offSet</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
			<span class="kt">byte</span><span class="o">[]</span> <span class="n">cache</span><span class="o">;</span>
			<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
			<span class="c1">// 对数据分段加密</span>
			<span class="k">while</span> <span class="o">(</span><span class="n">inputLen</span> <span class="o">-</span> <span class="n">offSet</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
				<span class="k">if</span> <span class="o">(</span><span class="n">inputLen</span> <span class="o">-</span> <span class="n">offSet</span> <span class="o">&gt;</span> <span class="no">MAX_ENCRYPT_BLOCK</span><span class="o">)</span> <span class="o">{</span>
					<span class="n">cache</span> <span class="o">=</span> <span class="n">cipher</span><span class="o">.</span><span class="na">doFinal</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="n">offSet</span><span class="o">,</span> <span class="no">MAX_ENCRYPT_BLOCK</span><span class="o">);</span>
				<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
					<span class="n">cache</span> <span class="o">=</span> <span class="n">cipher</span><span class="o">.</span><span class="na">doFinal</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="n">offSet</span><span class="o">,</span> <span class="n">inputLen</span> <span class="o">-</span> <span class="n">offSet</span><span class="o">);</span>
				<span class="o">}</span>
				<span class="n">out</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">cache</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">cache</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
				<span class="n">i</span><span class="o">++;</span>
				<span class="n">offSet</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="no">MAX_ENCRYPT_BLOCK</span><span class="o">;</span>
			<span class="o">}</span>
			<span class="n">encryptedData</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="na">toByteArray</span><span class="o">();</span>
			<span class="n">out</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
		<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
		<span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
			<span class="c1">// 防止流未关闭 浪费占用资源</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">out</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
				<span class="k">try</span> <span class="o">{</span>
					<span class="n">out</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
				<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
					<span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
				<span class="o">}</span>
			<span class="o">}</span>
		<span class="o">}</span>
		<span class="k">return</span> <span class="n">encryptedData</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="cm">/**
	 * RSA 私钥解密
	 * 
	 * @param data
	 * @param key
	 * @return
	 * @throws Exception
	 */</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">decryptData</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">ByteArrayOutputStream</span> <span class="n">out</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
		<span class="kt">byte</span><span class="o">[]</span> <span class="n">decryptedData</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
		<span class="k">try</span> <span class="o">{</span>
			<span class="nc">PKCS8EncodedKeySpec</span> <span class="n">pkcs8KeySpec</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PKCS8EncodedKeySpec</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
			<span class="nc">KeyFactory</span> <span class="n">keyFactory</span> <span class="o">=</span> <span class="nc">KeyFactory</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="no">ALGORITHM_RSA</span><span class="o">);</span>
			<span class="nc">Key</span> <span class="n">privateK</span> <span class="o">=</span> <span class="n">keyFactory</span><span class="o">.</span><span class="na">generatePrivate</span><span class="o">(</span><span class="n">pkcs8KeySpec</span><span class="o">);</span>
			<span class="nc">Cipher</span> <span class="n">cipher</span> <span class="o">=</span> <span class="nc">Cipher</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">keyFactory</span><span class="o">.</span><span class="na">getAlgorithm</span><span class="o">());</span>
			<span class="n">cipher</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="nc">Cipher</span><span class="o">.</span><span class="na">DECRYPT_MODE</span><span class="o">,</span> <span class="n">privateK</span><span class="o">);</span>
			<span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ByteArrayOutputStream</span><span class="o">();</span>
			<span class="kt">int</span> <span class="n">inputLen</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
			<span class="kt">int</span> <span class="n">offSet</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
			<span class="kt">byte</span><span class="o">[]</span> <span class="n">cache</span><span class="o">;</span>
			<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
			<span class="c1">// 对数据分段解密</span>
			<span class="k">while</span> <span class="o">(</span><span class="n">inputLen</span> <span class="o">-</span> <span class="n">offSet</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
				<span class="k">if</span> <span class="o">(</span><span class="n">inputLen</span> <span class="o">-</span> <span class="n">offSet</span> <span class="o">&gt;</span> <span class="no">MAX_DECRYPT_BLOCK</span><span class="o">)</span> <span class="o">{</span>
					<span class="n">cache</span> <span class="o">=</span> <span class="n">cipher</span><span class="o">.</span><span class="na">doFinal</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="n">offSet</span><span class="o">,</span> <span class="no">MAX_DECRYPT_BLOCK</span><span class="o">);</span>
				<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
					<span class="n">cache</span> <span class="o">=</span> <span class="n">cipher</span><span class="o">.</span><span class="na">doFinal</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="n">offSet</span><span class="o">,</span> <span class="n">inputLen</span> <span class="o">-</span> <span class="n">offSet</span><span class="o">);</span>
				<span class="o">}</span>
				<span class="n">out</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">cache</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">cache</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
				<span class="n">i</span><span class="o">++;</span>
				<span class="n">offSet</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="no">MAX_DECRYPT_BLOCK</span><span class="o">;</span>
			<span class="o">}</span>
			<span class="n">decryptedData</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="na">toByteArray</span><span class="o">();</span>
			<span class="n">out</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
		<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
		<span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
			<span class="c1">// 防止流未关闭 浪费占用资源</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">out</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
				<span class="k">try</span> <span class="o">{</span>
					<span class="n">out</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
				<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
					<span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
				<span class="o">}</span>
			<span class="o">}</span>
		<span class="o">}</span>
		<span class="k">return</span> <span class="n">decryptedData</span><span class="o">;</span>
	<span class="o">}</span>

<span class="o">}</span>

</pre></table></code></div></div><h2 id="其他">其他</h2></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/technology-%E6%8A%80%E6%9C%AF/'>Technology^技术</a>, <a href='/categories/algorithm-%E7%AE%97%E6%B3%95/'>Algorithm^算法</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/writing/" class="post-tag no-text-decoration" >writing</a> <a href="/tags/algorithm/" class="post-tag no-text-decoration" >Algorithm</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=数据加密 - Narule&url=https://narule.github.io/posts/%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=数据加密 - Narule&u=https://narule.github.io/posts/%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=数据加密 - Narule&url=https://narule.github.io/posts/%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%87%E5%BF%98%E5%BD%95/">互联网备忘录</a><li><a href="/posts/%E7%94%A8%E6%88%B7%E6%8C%87%E7%BA%B9/">用户指纹</a><li><a href="/posts/%E5%85%B3%E4%BA%8Enetty/">关于netty</a><li><a href="/posts/%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%AE%BE%E8%AE%A1-The-design-of-an-automatically-updated-blog/">The design of an automatically updated blog | 自动更新博客的设计</a><li><a href="/posts/AbstractQueuedSynchronizer%E6%8A%BD%E8%B1%A1%E7%B1%BB-%E9%98%BB%E5%A1%9E%E9%94%81/">AbstractQueuedSynchronizer抽象类-阻塞锁</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/writing/">writing</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/think/">Think</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/docker/">docker</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/website/">website</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/map/">map</a> <a class="post-tag" href="/tags/nginx/">nginx</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/%E5%9F%BA%E4%BA%8E%E9%9A%8F%E6%9C%BA%E5%AE%9A%E4%BD%8D%E7%9A%84%E5%9C%B0%E5%9B%BE%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E7%AE%97%E6%B3%95/"><div class="card-body"> <span class="timeago small" > Jun 13, 2021 <i class="unloaded">2021-06-13T07:29:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>基于随机定位的地图信息获取方式</h3><div class="text-muted small"><p> 基于随机定位的地图信息获取方式 基本定义 场景 一个应用要用到地图，地图拖动时，要填补新的版图上的地理信息 目的 快速获取屏幕内需要的地图信息，不获取多余无用的地图信息 功能要点 1.确定地图范围，获取的信息不超出显示屏过多 （比如屏幕地图查询100平方米的信息，服务返回的信息不能超过130平米的地图信息） 2.动态快速获取信息，通过定位快速获取周围地理信息，第一时间从缓存...</p></div></div></a></div><div class="card"> <a href="/posts/%E8%8B%B1%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"><div class="card-body"> <span class="timeago small" > May 8, 2020 <i class="unloaded">2020-05-08T23:10:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>英文字符串排序算法</h3><div class="text-muted small"><p> 编程工作偶尔会遇到一些不常见问题需要处理，学编程处理问题也难免需要熟悉一些算法 以前学习的时候就遇到过一个看似简单的排序算法问题，当时的解决办法是我没有用过的，在此记录一下’’ 问题 - 英文字符串排序 如下几个英文单词或者字母 apple，car， a，family，sky，application，app，baby，back，background，bad，bbbbb，b...</p></div></div></a></div><div class="card"> <a href="/posts/Problem-%E8%AF%BE%E9%A2%98/"><div class="card-body"> <span class="timeago small" > Jul 10, 2020 <i class="unloaded">2020-07-10T22:01:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Problem^^课题</h3><div class="text-muted small"><p> 有时候有些事情做起来，会比较困难，可以先立一个课题去了解他，再看看要不要做</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/gaode_map/" class="btn btn-outline-primary"><p>高德地图API使用</p></a> <a href="/posts/shell/" class="btn btn-outline-primary"><p>shell</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="font-italic text-center text-muted small"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> var options = { scriptUrl: '//.disqus.com/embed.js', disqusConfig: function() { this.page.url = 'https://narule.github.io/posts/%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/'; this.page.identifier = '/posts/%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://cnblogs.com/narule">narule</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy/" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/writing/">writing</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/think/">Think</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/docker/">docker</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/website/">website</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/map/">map</a> <a class="post-tag" href="/tags/nginx/">nginx</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://narule.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>
