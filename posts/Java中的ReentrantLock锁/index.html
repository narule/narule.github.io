<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="theme" content="Chirpy v2.7.2"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="ReentrantLock锁" /><meta name="author" content="Narule" /><meta property="og:locale" content="en_US" /><meta name="description" content="ReentrantLock锁 ReentrantLock是Java中常用的锁，属于乐观锁类型，多线程并发情况下。能保证共享数据安全性，线程间有序性 ReentrantLock通过原子操作和阻塞实现锁原理，一般使用lock获取锁，unlock释放锁， 下面说一下锁的基本使用和底层基本实现原理，lock和unlock底层 lock的时候可能被其他线程获得所，那么此线程会阻塞自己，关键原理底层用到Unsafe类的API: CAS和park 使用 java.util.concurrent.locks.ReentrantLock类 在多线程环境下使用，创建锁对象，调用lock()获取锁开始处理逻辑，处理完unlock()释放锁。注意使用的时候lock和unlock必须成对出现，不然可能出现死锁或者严重堵塞的情况 unlock 1 2 3 4 5 //创建锁对象 ReentrantLock lock = new ReentrantLock(); lock.lock(); //获取锁（锁定） System.out.println(&quot;一段需要上锁的代码&quot;) lock.unlock(); //锁释放 执行完代码后，释放锁，让其他线程去获取，需要注意的是，多个线程使用的锁对象必须是同一个。 什么情况需要上锁，就是在多线程不安全的情况下，多个线程操作同一个对象。 如多个线程同时操作一个队列，offer()添加对象，两个线程同时offer，因为不是原子操作，很可能一个线程添加成功，另一个线程添加失败，延伸到一些业务中是要杜绝的问题。 可以用锁解决问题，我们可以定义一个队列同一时间只能被一个拿到锁的线程操作，即保证offer这种非原子操作完成后，释放锁，再让其他线程拿到锁后，才能offer，保证有序的offer，不会丢失信息。 示例 为了体现锁的作用，这里sleep睡眠0.1秒，增加哪个线程获取锁的随机性 因为线程唤醒后，会开始尝试获取锁，多个线程下竞争一把锁是随机的 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package javabasis.threads; import java.util.concurrent.locks.ReentrantLock; public class LockTest implements Runnable { public static ReentrantLock lock = new ReentrantLock();//锁 private int thold; public LockTest(int h) { this.thold = h; } public static void main(String[] args) { for (int i = 10; i &lt; 15; i++) { new Thread(new LockTest(i),&quot;name-&quot; + i).start(); } } @Override public void run() { try { Thread.sleep(100); lock.lock(); //获取锁 System.out.println(&quot;lock threadName:&quot; + Thread.currentThread().getName()); { System.out.print(&quot; writeStart &quot;); for (int i = 0; i &lt; 15; i++) { Thread.sleep(100); System.out.print(thold+&quot;,&quot;); } System.out.println(&quot; writeEnd&quot;); } System.out.println(&quot;unlock threadName:&quot; + Thread.currentThread().getName() + &quot;\r\n&quot;); lock.unlock(); //锁释放 } catch (InterruptedException e) { } } } 运行main方法输出结果： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 lock threadName:name-10 writeStart 10,10,10,10,10,10,10,10,10,10,10,10,10,10,10, writeEnd unlock threadName:name-10 lock threadName:name-14 writeStart 14,14,14,14,14,14,14,14,14,14,14,14,14,14,14, writeEnd unlock threadName:name-14 lock threadName:name-13 writeStart 13,13,13,13,13,13,13,13,13,13,13,13,13,13,13, writeEnd unlock threadName:name-13 lock threadName:name-11 writeStart 11,11,11,11,11,11,11,11,11,11,11,11,11,11,11, writeEnd unlock threadName:name-11 lock threadName:name-12 writeStart 12,12,12,12,12,12,12,12,12,12,12,12,12,12,12, writeEnd unlock threadName:name-12 这体现在多线程情况下，锁能做到让线程之间有序运行， 如果没有锁，情况可能是 12,13,13,10,10,10,12，没有锁其他线程可能插队执行System.out.print 将上锁的代码注释后输出结果： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 lock threadName:name-11 lock threadName:name-12 writeStart lock threadName:name-10 writeStart lock threadName:name-13 writeStart lock threadName:name-14 writeStart writeStart 14,12,10,11,13,11,12,14,10,13,10,13,14,12,11,10,14,12,11,13,14,11,13,12,10,13,10,12,14,11,11,13,10,12,14,14,10,12,11,13,11,14,13,12,10,14,10,11,13,12,14,12,11,13,10,14,10,11,12,13,12,14,11,13,10,11,10,14,13,12,11, writeEnd unlock threadName:name-11 13,12, writeEnd unlock threadName:name-12 writeEnd unlock threadName:name-13 14, writeEnd unlock threadName:name-14 10, writeEnd unlock threadName:name-10 原理 ReentrantLock主要用到unsafe的CAS和park两个功能实现锁（CAS + park ） 多个线程同时操作一个数N，使用原子（CAS）操作，原子操作能保证同一时间只能被一个线程修改，而修改数N成功后，返回true，其他线程修改失败，返回false， 这个原子操作可以定义线程是否拿到锁，返回true代表获取锁，返回false代表为没有拿到锁。 拿到锁的线程，自然是继续执行后续逻辑代码，而没有拿到锁的线程，则调用park，将线程（自己）阻塞。 线程阻塞需要其他线程唤醒，ReentrantLock中用到了链表用于存放等待或者阻塞的线程，每次线程阻塞，先将自己的线程信息放入链表尾部，再阻塞自己；之后需要拿到锁的线程，在调用unlock 释放锁时，从链表中获取阻塞线程，调用unpark 唤醒指定线程 Unsafe sun.misc.Unsafe是关键类，提供大量偏底层的API 包括CAS park sun.misc.Unsafe 此类在openjdk中可以查看 CAS 原子操作 compare and swapz(CAS)比较并交换，是原子性操作， 原理：当修改一个(内存中的)变量o的值N的时候，首先有个期望值expected，和一个更新值x，先比较N是否等于expected，等于，那么更新内存中的值为x值，否则不更新。 1 2 3 public final native boolean compareAndSwapInt(Object o, long offset, int expected, int x); 这里offset据了解，是对象的成员变量在内存中的偏移地址， 即底层一个对象object存放在内存中，读取的地址是0x2110，此对象的一个成员变量state的值也在内存中，但内存地址肯定不是0x2110 java中的CAS使用 java.util.concurrent.locks.AbstractQueuedSynchronizer 类 1 2 3 4 5 6 7 8 9 10 11 12 13 private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long stateOffset; static { try { stateOffset = unsafe.objectFieldOffset (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;state&quot;)); //获取成员变量state在内存中的偏移量 } catch (Exception ex) { throw new Error(ex); } } protected final boolean compareAndSetState(int expect, int update) { // See below for intrinsics setup to support this return unsafe.compareAndSwapInt(this, stateOffset, expect, update); } 在Java中，compareAndSetState这个操作如果更新成功，返回true,失败返回false，通过这个机制，可以定义锁（乐观锁）。 如三个线程A，B，C，在目标值为0的情况下，同时执行compareAndSetState(0,1) 去修改它 期望值是0，更新值是1，因为是原子操作，在第一个线程操作成功之后目标值变为1，返回true 所以另外两个线程就因为期望值为0不等于1，返回false。 我们可以理解为，返回true的线程拿到了锁。 最终调用的Java类是sun.misc.Unsafe park 阻塞 Java中可以通过unsafe.park()去阻塞（停止）一个线程，也可以通过unsafe.unpark()让一个阻塞线程恢复继续执行 unsafe.park() 阻塞(停止)当前线程 1 public native void park(boolean isAbsolute, long time); 根据debug测试，此方法能停止线程自己，最后通过其他线程唤醒 unsafe.unpark() 取消阻塞(唤醒)线程 1 public native void unpark(Object thread); 根据debug测试，此方法可以唤醒其他被park调用阻塞的线程 park与interrupt的区别 interrupt是Thread类的的API，park是Unsafe类的API，两者是有区别的。 测试了解，Thread.currentThread().interrupt(),线程会继续运行，而Unsafe.park(Thread.currentThread())就是直接阻塞线程，不继续运行代码。 获取锁 线程cas操作失败，可以park阻塞自己，让其他拥有锁的线程在unlock的时候释放自己，达到锁的效果 java.util.concurrent.locks.ReentrantLock的lock方法是 1 2 3 public void lock() { sync.lock(); } 而sync的实现类其中一个是java.util.concurrent.locks.ReentrantLock.NonfairSync 不公平锁，它的逻辑比较直接 1 2 3 4 5 6 7 8 9 /** NonfairSync */ final void lock() { if (compareAndSetState(0, 1))//cas操作，如果true 则表示操作成功，获取锁 setExclusiveOwnerThread(Thread.currentThread()); //设置获取锁拥有者为当前线程 else acquire(1);//获取锁失败，锁住线程(自己) } 获取失败后阻塞线程 如果获取锁失败，会再尝试一次，失败后，将线程（自己）阻塞 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public final void acquire(int arg) { if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } protected final boolean tryAcquire(int acquires) { return nonfairTryAcquire(acquires); } final boolean nonfairTryAcquire(int acquires) { final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) { //如果期望值为0，内存值也为0，再次尝试获取锁（此时其他线程也可能尝试获取锁） if (compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); //第二次获取成功，放回true return true; } } else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); return true; } return false; //没有获取到锁，返回false，则 !tryAcquire(arg) 为true，执行acquireQueued(addWaiter(Node.EXCLUSIVE), arg) } 获取锁失败，线程会进入循环，acquireQueued 方法中for是个无限循环，除非获取锁成功后，才会return。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 //获取锁失败后，准备阻塞线程（自己） //阻塞之前，添加节点存放到链表，其他线程可以通过这个链表唤醒此线程 private Node addWaiter(Node mode) { Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure Node pred = tail; if (pred != null) { node.prev = pred; if (compareAndSetTail(pred, node)) {//cas操作 pred.next = node; return node; } } enq(node); return node; } // 在此方法直到获取锁成功才会跳出循环 final boolean acquireQueued(final Node node, int arg) { boolean failed = true; try { boolean interrupted = false; for (;;) { final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) { setHead(node); p.next = null; // help GC failed = false; return interrupted; //获取锁成功之后才会return跳出此方法 } if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; //如果满足阻塞条件 parkAndCheckInterrupt()) interrupted = true; } } finally { if (failed) cancelAcquire(node); } } private final boolean parkAndCheckInterrupt() { LockSupport.park(this);//停止线程（自己） return Thread.interrupted(); } 释放锁 一个线程拿到锁之后，执行完关键代码，必须unlock释放锁的，否则其他线程永远拿不到锁 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public void unlock() { sync.release(1); } public final boolean release(int arg) { if (tryRelease(arg)) { Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; } return false; } //java.util.concurrent.locks.ReentrantLock.Sync 的tryRelease protected final boolean tryRelease(int releases) { int c = getState() - releases; //这里一般是 1 - 1 = 0 if (Thread.currentThread() != getExclusiveOwnerThread()) //只能是锁的拥有者释放锁 throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) { free = true; setExclusiveOwnerThread(null); } setState(c); //设置state为0，相当于释放锁，让其他线程compareAndSetState(0, 1)可能成功 return free; } protected final void setState(int newState) { state = newState; //没有cas操作 } setState不做cas操作是因为，只有拥有锁的线程才调用unlock，不存才并发混乱问题 其他线程没拿到锁不会设值成功，其他线程在此线程设置state为0之前，compareAndSetState(0, 1)都会失败，拿不到锁，此线程设置state为0之后，其他线程compareAndSetState(0, 1)才有可能成功，返回true从而拿到锁 释放线程 线程在获取锁失败后，有可能阻塞线程（自己），在阻塞之前把阻塞线程信息放入链表的 释放锁之后，线程会尝试通过链表释放其他线程（一个），让一个阻塞线程恢复运行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 private void unparkSuccessor(Node node) { int ws = node.waitStatus; if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); Node s = node.next; if (s == null || s.waitStatus &gt; 0) { s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) // 循环获取前面的节点 if (t.waitStatus &lt;= 0) s = t; //循环，找到链表最前面需要被唤醒的线程 } if (s != null) LockSupport.unpark(s.thread); //唤醒（释放）被阻塞的线程 } 阻塞线程被取消阻塞后如何拿到锁(ReentrantLock中) 有时候线程被中断后，唤醒继续执行后面的代码， 线程没有拿到锁之后主动阻塞自己的，但所还没拿到，被唤醒之后怎么去尝试重新获取锁呢？ 里面有一个for循环 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 final void lock() { if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread());//拿到锁 else acquire(1); //没有拿到锁 } // 上锁失败，会添加一个节点，节点包含线程信息，将此节点放入队列 public final void acquire(int arg) { if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } // 存好节点后，将线程（自己）中断，等其他线程唤醒（自己） final boolean acquireQueued(final Node node, int arg) { boolean failed = true; try { boolean interrupted = false; for (;;) {//循环 被唤醒后线程还是在此处循环 final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) {//尝试获取锁 setHead(node); p.next = null; // help GC failed = false; return interrupted; //如果拿到锁了，才会return } if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) //没拿到锁时，主动中断Thread.currentThread() interrupted = true; } } finally { if (failed) cancelAcquire(node); } } 被唤醒后继续执行compareAndSetState(0, 1)返回false没拿到锁，则继续循环或阻塞 compareAndSetState(0, 1) 这个操作是获取锁的关键" /><meta property="og:description" content="ReentrantLock锁 ReentrantLock是Java中常用的锁，属于乐观锁类型，多线程并发情况下。能保证共享数据安全性，线程间有序性 ReentrantLock通过原子操作和阻塞实现锁原理，一般使用lock获取锁，unlock释放锁， 下面说一下锁的基本使用和底层基本实现原理，lock和unlock底层 lock的时候可能被其他线程获得所，那么此线程会阻塞自己，关键原理底层用到Unsafe类的API: CAS和park 使用 java.util.concurrent.locks.ReentrantLock类 在多线程环境下使用，创建锁对象，调用lock()获取锁开始处理逻辑，处理完unlock()释放锁。注意使用的时候lock和unlock必须成对出现，不然可能出现死锁或者严重堵塞的情况 unlock 1 2 3 4 5 //创建锁对象 ReentrantLock lock = new ReentrantLock(); lock.lock(); //获取锁（锁定） System.out.println(&quot;一段需要上锁的代码&quot;) lock.unlock(); //锁释放 执行完代码后，释放锁，让其他线程去获取，需要注意的是，多个线程使用的锁对象必须是同一个。 什么情况需要上锁，就是在多线程不安全的情况下，多个线程操作同一个对象。 如多个线程同时操作一个队列，offer()添加对象，两个线程同时offer，因为不是原子操作，很可能一个线程添加成功，另一个线程添加失败，延伸到一些业务中是要杜绝的问题。 可以用锁解决问题，我们可以定义一个队列同一时间只能被一个拿到锁的线程操作，即保证offer这种非原子操作完成后，释放锁，再让其他线程拿到锁后，才能offer，保证有序的offer，不会丢失信息。 示例 为了体现锁的作用，这里sleep睡眠0.1秒，增加哪个线程获取锁的随机性 因为线程唤醒后，会开始尝试获取锁，多个线程下竞争一把锁是随机的 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package javabasis.threads; import java.util.concurrent.locks.ReentrantLock; public class LockTest implements Runnable { public static ReentrantLock lock = new ReentrantLock();//锁 private int thold; public LockTest(int h) { this.thold = h; } public static void main(String[] args) { for (int i = 10; i &lt; 15; i++) { new Thread(new LockTest(i),&quot;name-&quot; + i).start(); } } @Override public void run() { try { Thread.sleep(100); lock.lock(); //获取锁 System.out.println(&quot;lock threadName:&quot; + Thread.currentThread().getName()); { System.out.print(&quot; writeStart &quot;); for (int i = 0; i &lt; 15; i++) { Thread.sleep(100); System.out.print(thold+&quot;,&quot;); } System.out.println(&quot; writeEnd&quot;); } System.out.println(&quot;unlock threadName:&quot; + Thread.currentThread().getName() + &quot;\r\n&quot;); lock.unlock(); //锁释放 } catch (InterruptedException e) { } } } 运行main方法输出结果： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 lock threadName:name-10 writeStart 10,10,10,10,10,10,10,10,10,10,10,10,10,10,10, writeEnd unlock threadName:name-10 lock threadName:name-14 writeStart 14,14,14,14,14,14,14,14,14,14,14,14,14,14,14, writeEnd unlock threadName:name-14 lock threadName:name-13 writeStart 13,13,13,13,13,13,13,13,13,13,13,13,13,13,13, writeEnd unlock threadName:name-13 lock threadName:name-11 writeStart 11,11,11,11,11,11,11,11,11,11,11,11,11,11,11, writeEnd unlock threadName:name-11 lock threadName:name-12 writeStart 12,12,12,12,12,12,12,12,12,12,12,12,12,12,12, writeEnd unlock threadName:name-12 这体现在多线程情况下，锁能做到让线程之间有序运行， 如果没有锁，情况可能是 12,13,13,10,10,10,12，没有锁其他线程可能插队执行System.out.print 将上锁的代码注释后输出结果： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 lock threadName:name-11 lock threadName:name-12 writeStart lock threadName:name-10 writeStart lock threadName:name-13 writeStart lock threadName:name-14 writeStart writeStart 14,12,10,11,13,11,12,14,10,13,10,13,14,12,11,10,14,12,11,13,14,11,13,12,10,13,10,12,14,11,11,13,10,12,14,14,10,12,11,13,11,14,13,12,10,14,10,11,13,12,14,12,11,13,10,14,10,11,12,13,12,14,11,13,10,11,10,14,13,12,11, writeEnd unlock threadName:name-11 13,12, writeEnd unlock threadName:name-12 writeEnd unlock threadName:name-13 14, writeEnd unlock threadName:name-14 10, writeEnd unlock threadName:name-10 原理 ReentrantLock主要用到unsafe的CAS和park两个功能实现锁（CAS + park ） 多个线程同时操作一个数N，使用原子（CAS）操作，原子操作能保证同一时间只能被一个线程修改，而修改数N成功后，返回true，其他线程修改失败，返回false， 这个原子操作可以定义线程是否拿到锁，返回true代表获取锁，返回false代表为没有拿到锁。 拿到锁的线程，自然是继续执行后续逻辑代码，而没有拿到锁的线程，则调用park，将线程（自己）阻塞。 线程阻塞需要其他线程唤醒，ReentrantLock中用到了链表用于存放等待或者阻塞的线程，每次线程阻塞，先将自己的线程信息放入链表尾部，再阻塞自己；之后需要拿到锁的线程，在调用unlock 释放锁时，从链表中获取阻塞线程，调用unpark 唤醒指定线程 Unsafe sun.misc.Unsafe是关键类，提供大量偏底层的API 包括CAS park sun.misc.Unsafe 此类在openjdk中可以查看 CAS 原子操作 compare and swapz(CAS)比较并交换，是原子性操作， 原理：当修改一个(内存中的)变量o的值N的时候，首先有个期望值expected，和一个更新值x，先比较N是否等于expected，等于，那么更新内存中的值为x值，否则不更新。 1 2 3 public final native boolean compareAndSwapInt(Object o, long offset, int expected, int x); 这里offset据了解，是对象的成员变量在内存中的偏移地址， 即底层一个对象object存放在内存中，读取的地址是0x2110，此对象的一个成员变量state的值也在内存中，但内存地址肯定不是0x2110 java中的CAS使用 java.util.concurrent.locks.AbstractQueuedSynchronizer 类 1 2 3 4 5 6 7 8 9 10 11 12 13 private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long stateOffset; static { try { stateOffset = unsafe.objectFieldOffset (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;state&quot;)); //获取成员变量state在内存中的偏移量 } catch (Exception ex) { throw new Error(ex); } } protected final boolean compareAndSetState(int expect, int update) { // See below for intrinsics setup to support this return unsafe.compareAndSwapInt(this, stateOffset, expect, update); } 在Java中，compareAndSetState这个操作如果更新成功，返回true,失败返回false，通过这个机制，可以定义锁（乐观锁）。 如三个线程A，B，C，在目标值为0的情况下，同时执行compareAndSetState(0,1) 去修改它 期望值是0，更新值是1，因为是原子操作，在第一个线程操作成功之后目标值变为1，返回true 所以另外两个线程就因为期望值为0不等于1，返回false。 我们可以理解为，返回true的线程拿到了锁。 最终调用的Java类是sun.misc.Unsafe park 阻塞 Java中可以通过unsafe.park()去阻塞（停止）一个线程，也可以通过unsafe.unpark()让一个阻塞线程恢复继续执行 unsafe.park() 阻塞(停止)当前线程 1 public native void park(boolean isAbsolute, long time); 根据debug测试，此方法能停止线程自己，最后通过其他线程唤醒 unsafe.unpark() 取消阻塞(唤醒)线程 1 public native void unpark(Object thread); 根据debug测试，此方法可以唤醒其他被park调用阻塞的线程 park与interrupt的区别 interrupt是Thread类的的API，park是Unsafe类的API，两者是有区别的。 测试了解，Thread.currentThread().interrupt(),线程会继续运行，而Unsafe.park(Thread.currentThread())就是直接阻塞线程，不继续运行代码。 获取锁 线程cas操作失败，可以park阻塞自己，让其他拥有锁的线程在unlock的时候释放自己，达到锁的效果 java.util.concurrent.locks.ReentrantLock的lock方法是 1 2 3 public void lock() { sync.lock(); } 而sync的实现类其中一个是java.util.concurrent.locks.ReentrantLock.NonfairSync 不公平锁，它的逻辑比较直接 1 2 3 4 5 6 7 8 9 /** NonfairSync */ final void lock() { if (compareAndSetState(0, 1))//cas操作，如果true 则表示操作成功，获取锁 setExclusiveOwnerThread(Thread.currentThread()); //设置获取锁拥有者为当前线程 else acquire(1);//获取锁失败，锁住线程(自己) } 获取失败后阻塞线程 如果获取锁失败，会再尝试一次，失败后，将线程（自己）阻塞 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public final void acquire(int arg) { if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } protected final boolean tryAcquire(int acquires) { return nonfairTryAcquire(acquires); } final boolean nonfairTryAcquire(int acquires) { final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) { //如果期望值为0，内存值也为0，再次尝试获取锁（此时其他线程也可能尝试获取锁） if (compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); //第二次获取成功，放回true return true; } } else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); return true; } return false; //没有获取到锁，返回false，则 !tryAcquire(arg) 为true，执行acquireQueued(addWaiter(Node.EXCLUSIVE), arg) } 获取锁失败，线程会进入循环，acquireQueued 方法中for是个无限循环，除非获取锁成功后，才会return。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 //获取锁失败后，准备阻塞线程（自己） //阻塞之前，添加节点存放到链表，其他线程可以通过这个链表唤醒此线程 private Node addWaiter(Node mode) { Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure Node pred = tail; if (pred != null) { node.prev = pred; if (compareAndSetTail(pred, node)) {//cas操作 pred.next = node; return node; } } enq(node); return node; } // 在此方法直到获取锁成功才会跳出循环 final boolean acquireQueued(final Node node, int arg) { boolean failed = true; try { boolean interrupted = false; for (;;) { final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) { setHead(node); p.next = null; // help GC failed = false; return interrupted; //获取锁成功之后才会return跳出此方法 } if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; //如果满足阻塞条件 parkAndCheckInterrupt()) interrupted = true; } } finally { if (failed) cancelAcquire(node); } } private final boolean parkAndCheckInterrupt() { LockSupport.park(this);//停止线程（自己） return Thread.interrupted(); } 释放锁 一个线程拿到锁之后，执行完关键代码，必须unlock释放锁的，否则其他线程永远拿不到锁 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public void unlock() { sync.release(1); } public final boolean release(int arg) { if (tryRelease(arg)) { Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; } return false; } //java.util.concurrent.locks.ReentrantLock.Sync 的tryRelease protected final boolean tryRelease(int releases) { int c = getState() - releases; //这里一般是 1 - 1 = 0 if (Thread.currentThread() != getExclusiveOwnerThread()) //只能是锁的拥有者释放锁 throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) { free = true; setExclusiveOwnerThread(null); } setState(c); //设置state为0，相当于释放锁，让其他线程compareAndSetState(0, 1)可能成功 return free; } protected final void setState(int newState) { state = newState; //没有cas操作 } setState不做cas操作是因为，只有拥有锁的线程才调用unlock，不存才并发混乱问题 其他线程没拿到锁不会设值成功，其他线程在此线程设置state为0之前，compareAndSetState(0, 1)都会失败，拿不到锁，此线程设置state为0之后，其他线程compareAndSetState(0, 1)才有可能成功，返回true从而拿到锁 释放线程 线程在获取锁失败后，有可能阻塞线程（自己），在阻塞之前把阻塞线程信息放入链表的 释放锁之后，线程会尝试通过链表释放其他线程（一个），让一个阻塞线程恢复运行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 private void unparkSuccessor(Node node) { int ws = node.waitStatus; if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); Node s = node.next; if (s == null || s.waitStatus &gt; 0) { s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) // 循环获取前面的节点 if (t.waitStatus &lt;= 0) s = t; //循环，找到链表最前面需要被唤醒的线程 } if (s != null) LockSupport.unpark(s.thread); //唤醒（释放）被阻塞的线程 } 阻塞线程被取消阻塞后如何拿到锁(ReentrantLock中) 有时候线程被中断后，唤醒继续执行后面的代码， 线程没有拿到锁之后主动阻塞自己的，但所还没拿到，被唤醒之后怎么去尝试重新获取锁呢？ 里面有一个for循环 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 final void lock() { if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread());//拿到锁 else acquire(1); //没有拿到锁 } // 上锁失败，会添加一个节点，节点包含线程信息，将此节点放入队列 public final void acquire(int arg) { if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } // 存好节点后，将线程（自己）中断，等其他线程唤醒（自己） final boolean acquireQueued(final Node node, int arg) { boolean failed = true; try { boolean interrupted = false; for (;;) {//循环 被唤醒后线程还是在此处循环 final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) {//尝试获取锁 setHead(node); p.next = null; // help GC failed = false; return interrupted; //如果拿到锁了，才会return } if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) //没拿到锁时，主动中断Thread.currentThread() interrupted = true; } } finally { if (failed) cancelAcquire(node); } } 被唤醒后继续执行compareAndSetState(0, 1)返回false没拿到锁，则继续循环或阻塞 compareAndSetState(0, 1) 这个操作是获取锁的关键" /><link rel="canonical" href="https://narule.github.io/posts/Java%E4%B8%AD%E7%9A%84ReentrantLock%E9%94%81/" /><meta property="og:url" content="https://narule.github.io/posts/Java%E4%B8%AD%E7%9A%84ReentrantLock%E9%94%81/" /><meta property="og:site_name" content="Narule" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-12-26T21:10:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="ReentrantLock锁" /><meta name="twitter:site" content="@no_twitter" /><meta name="twitter:creator" content="@Narule" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"ReentrantLock锁 ReentrantLock是Java中常用的锁，属于乐观锁类型，多线程并发情况下。能保证共享数据安全性，线程间有序性 ReentrantLock通过原子操作和阻塞实现锁原理，一般使用lock获取锁，unlock释放锁， 下面说一下锁的基本使用和底层基本实现原理，lock和unlock底层 lock的时候可能被其他线程获得所，那么此线程会阻塞自己，关键原理底层用到Unsafe类的API: CAS和park 使用 java.util.concurrent.locks.ReentrantLock类 在多线程环境下使用，创建锁对象，调用lock()获取锁开始处理逻辑，处理完unlock()释放锁。注意使用的时候lock和unlock必须成对出现，不然可能出现死锁或者严重堵塞的情况 unlock 1 2 3 4 5 //创建锁对象 ReentrantLock lock = new ReentrantLock(); lock.lock(); //获取锁（锁定） System.out.println(&quot;一段需要上锁的代码&quot;) lock.unlock(); //锁释放 执行完代码后，释放锁，让其他线程去获取，需要注意的是，多个线程使用的锁对象必须是同一个。 什么情况需要上锁，就是在多线程不安全的情况下，多个线程操作同一个对象。 如多个线程同时操作一个队列，offer()添加对象，两个线程同时offer，因为不是原子操作，很可能一个线程添加成功，另一个线程添加失败，延伸到一些业务中是要杜绝的问题。 可以用锁解决问题，我们可以定义一个队列同一时间只能被一个拿到锁的线程操作，即保证offer这种非原子操作完成后，释放锁，再让其他线程拿到锁后，才能offer，保证有序的offer，不会丢失信息。 示例 为了体现锁的作用，这里sleep睡眠0.1秒，增加哪个线程获取锁的随机性 因为线程唤醒后，会开始尝试获取锁，多个线程下竞争一把锁是随机的 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package javabasis.threads; import java.util.concurrent.locks.ReentrantLock; public class LockTest implements Runnable { public static ReentrantLock lock = new ReentrantLock();//锁 private int thold; public LockTest(int h) { this.thold = h; } public static void main(String[] args) { for (int i = 10; i &lt; 15; i++) { new Thread(new LockTest(i),&quot;name-&quot; + i).start(); } } @Override public void run() { try { Thread.sleep(100); lock.lock(); //获取锁 System.out.println(&quot;lock threadName:&quot; + Thread.currentThread().getName()); { System.out.print(&quot; writeStart &quot;); for (int i = 0; i &lt; 15; i++) { Thread.sleep(100); System.out.print(thold+&quot;,&quot;); } System.out.println(&quot; writeEnd&quot;); } System.out.println(&quot;unlock threadName:&quot; + Thread.currentThread().getName() + &quot;\\r\\n&quot;); lock.unlock(); //锁释放 } catch (InterruptedException e) { } } } 运行main方法输出结果： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 lock threadName:name-10 writeStart 10,10,10,10,10,10,10,10,10,10,10,10,10,10,10, writeEnd unlock threadName:name-10 lock threadName:name-14 writeStart 14,14,14,14,14,14,14,14,14,14,14,14,14,14,14, writeEnd unlock threadName:name-14 lock threadName:name-13 writeStart 13,13,13,13,13,13,13,13,13,13,13,13,13,13,13, writeEnd unlock threadName:name-13 lock threadName:name-11 writeStart 11,11,11,11,11,11,11,11,11,11,11,11,11,11,11, writeEnd unlock threadName:name-11 lock threadName:name-12 writeStart 12,12,12,12,12,12,12,12,12,12,12,12,12,12,12, writeEnd unlock threadName:name-12 这体现在多线程情况下，锁能做到让线程之间有序运行， 如果没有锁，情况可能是 12,13,13,10,10,10,12，没有锁其他线程可能插队执行System.out.print 将上锁的代码注释后输出结果： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 lock threadName:name-11 lock threadName:name-12 writeStart lock threadName:name-10 writeStart lock threadName:name-13 writeStart lock threadName:name-14 writeStart writeStart 14,12,10,11,13,11,12,14,10,13,10,13,14,12,11,10,14,12,11,13,14,11,13,12,10,13,10,12,14,11,11,13,10,12,14,14,10,12,11,13,11,14,13,12,10,14,10,11,13,12,14,12,11,13,10,14,10,11,12,13,12,14,11,13,10,11,10,14,13,12,11, writeEnd unlock threadName:name-11 13,12, writeEnd unlock threadName:name-12 writeEnd unlock threadName:name-13 14, writeEnd unlock threadName:name-14 10, writeEnd unlock threadName:name-10 原理 ReentrantLock主要用到unsafe的CAS和park两个功能实现锁（CAS + park ） 多个线程同时操作一个数N，使用原子（CAS）操作，原子操作能保证同一时间只能被一个线程修改，而修改数N成功后，返回true，其他线程修改失败，返回false， 这个原子操作可以定义线程是否拿到锁，返回true代表获取锁，返回false代表为没有拿到锁。 拿到锁的线程，自然是继续执行后续逻辑代码，而没有拿到锁的线程，则调用park，将线程（自己）阻塞。 线程阻塞需要其他线程唤醒，ReentrantLock中用到了链表用于存放等待或者阻塞的线程，每次线程阻塞，先将自己的线程信息放入链表尾部，再阻塞自己；之后需要拿到锁的线程，在调用unlock 释放锁时，从链表中获取阻塞线程，调用unpark 唤醒指定线程 Unsafe sun.misc.Unsafe是关键类，提供大量偏底层的API 包括CAS park sun.misc.Unsafe 此类在openjdk中可以查看 CAS 原子操作 compare and swapz(CAS)比较并交换，是原子性操作， 原理：当修改一个(内存中的)变量o的值N的时候，首先有个期望值expected，和一个更新值x，先比较N是否等于expected，等于，那么更新内存中的值为x值，否则不更新。 1 2 3 public final native boolean compareAndSwapInt(Object o, long offset, int expected, int x); 这里offset据了解，是对象的成员变量在内存中的偏移地址， 即底层一个对象object存放在内存中，读取的地址是0x2110，此对象的一个成员变量state的值也在内存中，但内存地址肯定不是0x2110 java中的CAS使用 java.util.concurrent.locks.AbstractQueuedSynchronizer 类 1 2 3 4 5 6 7 8 9 10 11 12 13 private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long stateOffset; static { try { stateOffset = unsafe.objectFieldOffset (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;state&quot;)); //获取成员变量state在内存中的偏移量 } catch (Exception ex) { throw new Error(ex); } } protected final boolean compareAndSetState(int expect, int update) { // See below for intrinsics setup to support this return unsafe.compareAndSwapInt(this, stateOffset, expect, update); } 在Java中，compareAndSetState这个操作如果更新成功，返回true,失败返回false，通过这个机制，可以定义锁（乐观锁）。 如三个线程A，B，C，在目标值为0的情况下，同时执行compareAndSetState(0,1) 去修改它 期望值是0，更新值是1，因为是原子操作，在第一个线程操作成功之后目标值变为1，返回true 所以另外两个线程就因为期望值为0不等于1，返回false。 我们可以理解为，返回true的线程拿到了锁。 最终调用的Java类是sun.misc.Unsafe park 阻塞 Java中可以通过unsafe.park()去阻塞（停止）一个线程，也可以通过unsafe.unpark()让一个阻塞线程恢复继续执行 unsafe.park() 阻塞(停止)当前线程 1 public native void park(boolean isAbsolute, long time); 根据debug测试，此方法能停止线程自己，最后通过其他线程唤醒 unsafe.unpark() 取消阻塞(唤醒)线程 1 public native void unpark(Object thread); 根据debug测试，此方法可以唤醒其他被park调用阻塞的线程 park与interrupt的区别 interrupt是Thread类的的API，park是Unsafe类的API，两者是有区别的。 测试了解，Thread.currentThread().interrupt(),线程会继续运行，而Unsafe.park(Thread.currentThread())就是直接阻塞线程，不继续运行代码。 获取锁 线程cas操作失败，可以park阻塞自己，让其他拥有锁的线程在unlock的时候释放自己，达到锁的效果 java.util.concurrent.locks.ReentrantLock的lock方法是 1 2 3 public void lock() { sync.lock(); } 而sync的实现类其中一个是java.util.concurrent.locks.ReentrantLock.NonfairSync 不公平锁，它的逻辑比较直接 1 2 3 4 5 6 7 8 9 /** NonfairSync */ final void lock() { if (compareAndSetState(0, 1))//cas操作，如果true 则表示操作成功，获取锁 setExclusiveOwnerThread(Thread.currentThread()); //设置获取锁拥有者为当前线程 else acquire(1);//获取锁失败，锁住线程(自己) } 获取失败后阻塞线程 如果获取锁失败，会再尝试一次，失败后，将线程（自己）阻塞 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public final void acquire(int arg) { if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } protected final boolean tryAcquire(int acquires) { return nonfairTryAcquire(acquires); } final boolean nonfairTryAcquire(int acquires) { final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) { //如果期望值为0，内存值也为0，再次尝试获取锁（此时其他线程也可能尝试获取锁） if (compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); //第二次获取成功，放回true return true; } } else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); return true; } return false; //没有获取到锁，返回false，则 !tryAcquire(arg) 为true，执行acquireQueued(addWaiter(Node.EXCLUSIVE), arg) } 获取锁失败，线程会进入循环，acquireQueued 方法中for是个无限循环，除非获取锁成功后，才会return。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 //获取锁失败后，准备阻塞线程（自己） //阻塞之前，添加节点存放到链表，其他线程可以通过这个链表唤醒此线程 private Node addWaiter(Node mode) { Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure Node pred = tail; if (pred != null) { node.prev = pred; if (compareAndSetTail(pred, node)) {//cas操作 pred.next = node; return node; } } enq(node); return node; } // 在此方法直到获取锁成功才会跳出循环 final boolean acquireQueued(final Node node, int arg) { boolean failed = true; try { boolean interrupted = false; for (;;) { final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) { setHead(node); p.next = null; // help GC failed = false; return interrupted; //获取锁成功之后才会return跳出此方法 } if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; //如果满足阻塞条件 parkAndCheckInterrupt()) interrupted = true; } } finally { if (failed) cancelAcquire(node); } } private final boolean parkAndCheckInterrupt() { LockSupport.park(this);//停止线程（自己） return Thread.interrupted(); } 释放锁 一个线程拿到锁之后，执行完关键代码，必须unlock释放锁的，否则其他线程永远拿不到锁 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public void unlock() { sync.release(1); } public final boolean release(int arg) { if (tryRelease(arg)) { Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; } return false; } //java.util.concurrent.locks.ReentrantLock.Sync 的tryRelease protected final boolean tryRelease(int releases) { int c = getState() - releases; //这里一般是 1 - 1 = 0 if (Thread.currentThread() != getExclusiveOwnerThread()) //只能是锁的拥有者释放锁 throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) { free = true; setExclusiveOwnerThread(null); } setState(c); //设置state为0，相当于释放锁，让其他线程compareAndSetState(0, 1)可能成功 return free; } protected final void setState(int newState) { state = newState; //没有cas操作 } setState不做cas操作是因为，只有拥有锁的线程才调用unlock，不存才并发混乱问题 其他线程没拿到锁不会设值成功，其他线程在此线程设置state为0之前，compareAndSetState(0, 1)都会失败，拿不到锁，此线程设置state为0之后，其他线程compareAndSetState(0, 1)才有可能成功，返回true从而拿到锁 释放线程 线程在获取锁失败后，有可能阻塞线程（自己），在阻塞之前把阻塞线程信息放入链表的 释放锁之后，线程会尝试通过链表释放其他线程（一个），让一个阻塞线程恢复运行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 private void unparkSuccessor(Node node) { int ws = node.waitStatus; if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); Node s = node.next; if (s == null || s.waitStatus &gt; 0) { s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) // 循环获取前面的节点 if (t.waitStatus &lt;= 0) s = t; //循环，找到链表最前面需要被唤醒的线程 } if (s != null) LockSupport.unpark(s.thread); //唤醒（释放）被阻塞的线程 } 阻塞线程被取消阻塞后如何拿到锁(ReentrantLock中) 有时候线程被中断后，唤醒继续执行后面的代码， 线程没有拿到锁之后主动阻塞自己的，但所还没拿到，被唤醒之后怎么去尝试重新获取锁呢？ 里面有一个for循环 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 final void lock() { if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread());//拿到锁 else acquire(1); //没有拿到锁 } // 上锁失败，会添加一个节点，节点包含线程信息，将此节点放入队列 public final void acquire(int arg) { if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } // 存好节点后，将线程（自己）中断，等其他线程唤醒（自己） final boolean acquireQueued(final Node node, int arg) { boolean failed = true; try { boolean interrupted = false; for (;;) {//循环 被唤醒后线程还是在此处循环 final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) {//尝试获取锁 setHead(node); p.next = null; // help GC failed = false; return interrupted; //如果拿到锁了，才会return } if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) //没拿到锁时，主动中断Thread.currentThread() interrupted = true; } } finally { if (failed) cancelAcquire(node); } } 被唤醒后继续执行compareAndSetState(0, 1)返回false没拿到锁，则继续循环或阻塞 compareAndSetState(0, 1) 这个操作是获取锁的关键","headline":"ReentrantLock锁","dateModified":"2021-01-17T03:14:04+08:00","datePublished":"2020-12-26T21:10:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://narule.github.io/posts/Java%E4%B8%AD%E7%9A%84ReentrantLock%E9%94%81/"},"url":"https://narule.github.io/posts/Java%E4%B8%AD%E7%9A%84ReentrantLock%E9%94%81/","author":{"@type":"Person","name":"Narule"},"@type":"BlogPosting","@context":"https://schema.org"}</script><title>ReentrantLock锁 | Narule</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="preload" href="/assets/css/post.css" as="style"><link rel="stylesheet" href="/assets/css/post.css"><link rel="preload" as="style" href="/assets/css/lib/bootstrap-toc.min.css"><link rel="stylesheet" href="/assets/css/lib/bootstrap-toc.min.css" /> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="/assets/js/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-JVHJ82NYZT"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-JVHJ82NYZT'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://narule.github.io/avatar.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Narule</a></div><div class="site-subtitle font-italic">A Blog for Article; Chinese Blog is www.cnblogs.com/narule</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tabs/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tabs/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/tabs/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/tabs/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/narule" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/no_twitter" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['narule','163.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>ReentrantLock锁</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>ReentrantLock锁</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sat, Dec 26, 2020, 9:10 PM +0800" > Dec 26, 2020 <i class="unloaded">2020-12-26T21:10:00+08:00</i> </span> by <span class="author"> Narule </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Sun, Jan 17, 2021, 3:14 AM +0800" > Jan 17, 2021 <i class="unloaded">2021-01-17T03:14:04+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3346 words">18 min</span></div></div><div class="post-content"><h1 id="reentrantlock锁">ReentrantLock锁</h1><p>ReentrantLock是Java中常用的锁，属于乐观锁类型，多线程并发情况下。能保证共享数据安全性，线程间有序性 ReentrantLock通过原子操作和阻塞实现锁原理，一般使用lock获取锁，unlock释放锁， 下面说一下锁的基本使用和底层基本实现原理，lock和unlock底层</p><p>lock的时候可能被其他线程获得所，那么此线程会阻塞自己，关键原理底层用到Unsafe类的API: CAS和park</p><h2 id="使用">使用</h2><p><code class="language-plaintext highlighter-rouge">java.util.concurrent.locks.ReentrantLock</code>类</p><p>在多线程环境下使用，创建锁对象，调用lock()获取锁开始处理逻辑，处理完unlock()释放锁。注意使用的时候lock和unlock必须成对出现，不然可能出现死锁或者严重堵塞的情况</p><h3 id="unlock">unlock</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">//创建锁对象</span>
<span class="nc">ReentrantLock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ReentrantLock</span><span class="o">();</span>
<span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span> <span class="c1">//获取锁（锁定）</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"一段需要上锁的代码"</span><span class="o">)</span>
<span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span> <span class="c1">//锁释放</span>
</pre></table></code></div></div><p>执行完代码后，释放锁，让其他线程去获取，需要注意的是，多个线程使用的锁对象必须是同一个。</p><blockquote><p>什么情况需要上锁，就是在多线程不安全的情况下，多个线程操作同一个对象。 如多个线程同时操作一个队列，offer()添加对象，两个线程同时offer，因为不是原子操作，很可能一个线程添加成功，另一个线程添加失败，延伸到一些业务中是要杜绝的问题。</p><p>可以用锁解决问题，我们可以定义一个队列同一时间只能被一个拿到锁的线程操作，即保证offer这种非原子操作完成后，释放锁，再让其他线程拿到锁后，才能offer，保证有序的offer，不会丢失信息。</p></blockquote><h3 id="示例">示例</h3><p>为了体现锁的作用，这里sleep睡眠0.1秒，增加哪个线程获取锁的随机性 因为线程唤醒后，会开始尝试获取锁，多个线程下竞争一把锁是随机的</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">javabasis.threads</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.locks.ReentrantLock</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LockTest</span> <span class="kd">implements</span> <span class="nc">Runnable</span> <span class="o">{</span>
    
	<span class="kd">public</span> <span class="kd">static</span> <span class="nc">ReentrantLock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ReentrantLock</span><span class="o">();</span><span class="c1">//锁</span>
	<span class="kd">private</span> <span class="kt">int</span> <span class="n">thold</span><span class="o">;</span>
    
	<span class="kd">public</span> <span class="nf">LockTest</span><span class="o">(</span><span class="kt">int</span> <span class="n">h</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">thold</span> <span class="o">=</span> <span class="n">h</span><span class="o">;</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">15</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">LockTest</span><span class="o">(</span><span class="n">i</span><span class="o">),</span><span class="s">"name-"</span> <span class="o">+</span> <span class="n">i</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
		<span class="o">}</span>
	<span class="o">}</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">try</span> <span class="o">{</span>
			<span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
			<span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span> <span class="c1">//获取锁</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"lock threadName:"</span> <span class="o">+</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
			<span class="o">{</span>
				<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">" writeStart "</span><span class="o">);</span>
				<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">15</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
						<span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
					<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">thold</span><span class="o">+</span><span class="s">","</span><span class="o">);</span>
				<span class="o">}</span>
				<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">" writeEnd"</span><span class="o">);</span>
			<span class="o">}</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"unlock threadName:"</span> <span class="o">+</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">"\r\n"</span><span class="o">);</span>
			<span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span> <span class="c1">//锁释放 </span>
		<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>	
		<span class="o">}</span>		
	<span class="o">}</span>	
<span class="o">}</span>
</pre></table></code></div></div><p>运行main方法输出结果：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="n">lock</span> <span class="nl">threadName:</span><span class="n">name</span><span class="o">-</span><span class="mi">10</span>
 <span class="n">writeStart</span> <span class="mi">10</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span> <span class="n">writeEnd</span>
<span class="n">unlock</span> <span class="nl">threadName:</span><span class="n">name</span><span class="o">-</span><span class="mi">10</span>

<span class="n">lock</span> <span class="nl">threadName:</span><span class="n">name</span><span class="o">-</span><span class="mi">14</span>
 <span class="n">writeStart</span> <span class="mi">14</span><span class="o">,</span><span class="mi">14</span><span class="o">,</span><span class="mi">14</span><span class="o">,</span><span class="mi">14</span><span class="o">,</span><span class="mi">14</span><span class="o">,</span><span class="mi">14</span><span class="o">,</span><span class="mi">14</span><span class="o">,</span><span class="mi">14</span><span class="o">,</span><span class="mi">14</span><span class="o">,</span><span class="mi">14</span><span class="o">,</span><span class="mi">14</span><span class="o">,</span><span class="mi">14</span><span class="o">,</span><span class="mi">14</span><span class="o">,</span><span class="mi">14</span><span class="o">,</span><span class="mi">14</span><span class="o">,</span> <span class="n">writeEnd</span>
<span class="n">unlock</span> <span class="nl">threadName:</span><span class="n">name</span><span class="o">-</span><span class="mi">14</span>

<span class="n">lock</span> <span class="nl">threadName:</span><span class="n">name</span><span class="o">-</span><span class="mi">13</span>
 <span class="n">writeStart</span> <span class="mi">13</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span> <span class="n">writeEnd</span>
<span class="n">unlock</span> <span class="nl">threadName:</span><span class="n">name</span><span class="o">-</span><span class="mi">13</span>

<span class="n">lock</span> <span class="nl">threadName:</span><span class="n">name</span><span class="o">-</span><span class="mi">11</span>
 <span class="n">writeStart</span> <span class="mi">11</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span> <span class="n">writeEnd</span>
<span class="n">unlock</span> <span class="nl">threadName:</span><span class="n">name</span><span class="o">-</span><span class="mi">11</span>

<span class="n">lock</span> <span class="nl">threadName:</span><span class="n">name</span><span class="o">-</span><span class="mi">12</span>
 <span class="n">writeStart</span> <span class="mi">12</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span> <span class="n">writeEnd</span>
<span class="n">unlock</span> <span class="nl">threadName:</span><span class="n">name</span><span class="o">-</span><span class="mi">12</span>
</pre></table></code></div></div><p>这体现在多线程情况下，锁能做到让线程之间有序运行，</p><p>如果没有锁，情况可能是 12,13,13,10,10,10,12，没有锁其他线程可能插队执行<code class="language-plaintext highlighter-rouge">System.out.print</code></p><p>将上锁的代码注释后输出结果：</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="n">lock</span> <span class="nl">threadName:</span><span class="n">name</span><span class="o">-</span><span class="mi">11</span>
<span class="n">lock</span> <span class="nl">threadName:</span><span class="n">name</span><span class="o">-</span><span class="mi">12</span>
 <span class="n">writeStart</span> <span class="n">lock</span> <span class="nl">threadName:</span><span class="n">name</span><span class="o">-</span><span class="mi">10</span>
 <span class="n">writeStart</span> <span class="n">lock</span> <span class="nl">threadName:</span><span class="n">name</span><span class="o">-</span><span class="mi">13</span>
 <span class="n">writeStart</span> <span class="n">lock</span> <span class="nl">threadName:</span><span class="n">name</span><span class="o">-</span><span class="mi">14</span>
 <span class="n">writeStart</span>  <span class="n">writeStart</span> <span class="mi">14</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">14</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">14</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">14</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">14</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">14</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">14</span><span class="o">,</span><span class="mi">14</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">14</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">14</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">14</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">14</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">14</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">14</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span> <span class="n">writeEnd</span>
<span class="n">unlock</span> <span class="nl">threadName:</span><span class="n">name</span><span class="o">-</span><span class="mi">11</span>

<span class="mi">13</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span> <span class="n">writeEnd</span>
<span class="n">unlock</span> <span class="nl">threadName:</span><span class="n">name</span><span class="o">-</span><span class="mi">12</span>

 <span class="n">writeEnd</span>
<span class="n">unlock</span> <span class="nl">threadName:</span><span class="n">name</span><span class="o">-</span><span class="mi">13</span>

<span class="mi">14</span><span class="o">,</span> <span class="n">writeEnd</span>
<span class="n">unlock</span> <span class="nl">threadName:</span><span class="n">name</span><span class="o">-</span><span class="mi">14</span>

<span class="mi">10</span><span class="o">,</span> <span class="n">writeEnd</span>
<span class="n">unlock</span> <span class="nl">threadName:</span><span class="n">name</span><span class="o">-</span><span class="mi">10</span>
</pre></table></code></div></div><h2 id="原理">原理</h2><p>ReentrantLock主要用到unsafe的CAS和park两个功能实现锁（CAS + park ）</p><blockquote><p>多个线程同时操作一个数N，使用原子（CAS）操作，原子操作能保证同一时间只能被一个线程修改，而修改数N成功后，返回true，其他线程修改失败，返回false， 这个原子操作可以定义线程是否拿到锁，返回true代表获取锁，返回false代表为没有拿到锁。</p><p>拿到锁的线程，自然是继续执行后续逻辑代码，而没有拿到锁的线程，则调用park，将线程（自己）阻塞。</p><p>线程阻塞需要其他线程唤醒，ReentrantLock中用到了链表用于存放等待或者阻塞的线程，每次线程阻塞，先将自己的线程信息放入链表尾部，再阻塞自己；之后需要拿到锁的线程，在调用unlock 释放锁时，从链表中获取阻塞线程，调用unpark 唤醒指定线程</p></blockquote><h3 id="unsafe">Unsafe</h3><p>sun.misc.Unsafe是关键类，提供大量偏底层的API 包括CAS park <code class="language-plaintext highlighter-rouge">sun.misc.Unsafe</code> 此类在openjdk中可以查看</p><h3 id="cas-原子操作">CAS 原子操作</h3><p>compare and swapz(CAS)比较并交换，是原子性操作， 原理：当修改一个(内存中的)变量o的值N的时候，首先有个期望值expected，和一个更新值x，先比较N是否等于expected，等于，那么更新内存中的值为x值，否则不更新。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">final</span> <span class="kd">native</span> <span class="kt">boolean</span> <span class="nf">compareAndSwapInt</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">,</span> <span class="kt">long</span> <span class="n">offset</span><span class="o">,</span>
                                              <span class="kt">int</span> <span class="n">expected</span><span class="o">,</span>
                                              <span class="kt">int</span> <span class="n">x</span><span class="o">);</span>
</pre></table></code></div></div><p>这里offset据了解，是对象的成员变量在内存中的偏移地址， 即底层一个对象object存放在内存中，读取的地址是0x2110，此对象的一个成员变量state的值也在内存中，但内存地址肯定不是0x2110</p><h4 id="java中的cas使用">java中的CAS使用</h4><p><code class="language-plaintext highlighter-rouge">java.util.concurrent.locks.AbstractQueuedSynchronizer</code> 类</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Unsafe</span> <span class="n">unsafe</span> <span class="o">=</span> <span class="nc">Unsafe</span><span class="o">.</span><span class="na">getUnsafe</span><span class="o">();</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">stateOffset</span><span class="o">;</span>
<span class="kd">static</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">stateOffset</span> <span class="o">=</span> <span class="n">unsafe</span><span class="o">.</span><span class="na">objectFieldOffset</span>
                <span class="o">(</span><span class="nc">AbstractQueuedSynchronizer</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">"state"</span><span class="o">));</span> <span class="c1">//获取成员变量state在内存中的偏移量</span>

        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="o">(</span><span class="n">ex</span><span class="o">);</span> <span class="o">}</span>
    <span class="o">}</span>
<span class="kd">protected</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">compareAndSetState</span><span class="o">(</span><span class="kt">int</span> <span class="n">expect</span><span class="o">,</span> <span class="kt">int</span> <span class="n">update</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// See below for intrinsics setup to support this</span>
        <span class="k">return</span> <span class="n">unsafe</span><span class="o">.</span><span class="na">compareAndSwapInt</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">stateOffset</span><span class="o">,</span> <span class="n">expect</span><span class="o">,</span> <span class="n">update</span><span class="o">);</span>
    <span class="o">}</span>
</pre></table></code></div></div><p>在Java中，<strong>compareAndSetState</strong>这个操作如果更新成功，返回true,失败返回false，通过这个机制，可以定义锁（乐观锁）。 如三个线程A，B，C，在目标值为0的情况下，同时执行<code class="language-plaintext highlighter-rouge">compareAndSetState(0,1) </code> 去修改它 期望值是0，更新值是1，因为是原子操作，在第一个线程操作成功之后目标值变为1，返回true 所以另外两个线程就因为期望值为0不等于1，返回false。 我们可以理解为，返回true的线程拿到了锁。</p><p>最终调用的Java类是<code class="language-plaintext highlighter-rouge">sun.misc.Unsafe</code></p><h3 id="park-阻塞">park 阻塞</h3><p>Java中可以通过unsafe.park()去阻塞（停止）一个线程，也可以通过unsafe.unpark()让一个阻塞线程恢复继续执行</p><h4 id="unsafepark">unsafe.park()</h4><p>阻塞(停止)当前线程</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">native</span> <span class="kt">void</span> <span class="nf">park</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">isAbsolute</span><span class="o">,</span> <span class="kt">long</span> <span class="n">time</span><span class="o">);</span> 
</pre></table></code></div></div><p>根据debug测试，此方法能停止线程自己，最后通过其他线程唤醒</p><h4 id="unsafeunpark">unsafe.unpark()</h4><p>取消阻塞(唤醒)线程</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">native</span> <span class="kt">void</span> <span class="nf">unpark</span><span class="o">(</span><span class="nc">Object</span> <span class="n">thread</span><span class="o">);</span>
</pre></table></code></div></div><p>根据debug测试，此方法可以唤醒其他被park调用阻塞的线程</p><h4 id="park与interrupt的区别">park与interrupt的区别</h4><p>interrupt是Thread类的的API，park是Unsafe类的API，两者是有区别的。 测试了解，Thread.currentThread().interrupt(),线程会继续运行，而Unsafe.park(Thread.currentThread())就是直接阻塞线程，不继续运行代码。</p><h3 id="获取锁">获取锁</h3><p>线程cas操作失败，可以park阻塞自己，让其他拥有锁的线程在unlock的时候释放自己，达到锁的效果</p><p>java.util.concurrent.locks.ReentrantLock的lock方法是</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">sync</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
    <span class="o">}</span>
</pre></table></code></div></div><p>而sync的实现类其中一个是java.util.concurrent.locks.ReentrantLock.NonfairSync 不公平锁，它的逻辑比较直接</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="cm">/**
NonfairSync
*/</span>
<span class="kd">final</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetState</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">))</span><span class="c1">//cas操作，如果true 则表示操作成功，获取锁</span>
        <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">());</span> <span class="c1">//设置获取锁拥有者为当前线程</span>
    <span class="k">else</span>
        <span class="nf">acquire</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span><span class="c1">//获取锁失败，锁住线程(自己)</span>
<span class="o">}</span>
</pre></table></code></div></div><h4 id="获取失败后阻塞线程">获取失败后阻塞线程</h4><p>如果获取锁失败，会再尝试一次，失败后，将线程（自己）阻塞</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">acquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">tryAcquire</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
            <span class="n">acquireQueued</span><span class="o">(</span><span class="n">addWaiter</span><span class="o">(</span><span class="nc">Node</span><span class="o">.</span><span class="na">EXCLUSIVE</span><span class="o">),</span> <span class="n">arg</span><span class="o">))</span>
            <span class="n">selfInterrupt</span><span class="o">();</span>
    <span class="o">}</span>
<span class="kd">protected</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">tryAcquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">acquires</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="nf">nonfairTryAcquire</span><span class="o">(</span><span class="n">acquires</span><span class="o">);</span>
        <span class="o">}</span>
<span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">nonfairTryAcquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">acquires</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">final</span> <span class="nc">Thread</span> <span class="n">current</span> <span class="o">=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
            <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">getState</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span> 
			<span class="c1">//如果期望值为0，内存值也为0，再次尝试获取锁（此时其他线程也可能尝试获取锁）</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetState</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">acquires</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="n">current</span><span class="o">);</span> <span class="c1">//第二次获取成功，放回true</span>
                    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">current</span> <span class="o">==</span> <span class="n">getExclusiveOwnerThread</span><span class="o">())</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">nextc</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">acquires</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">nextc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="c1">// overflow</span>
                    <span class="k">throw</span> <span class="k">new</span> <span class="nf">Error</span><span class="o">(</span><span class="s">"Maximum lock count exceeded"</span><span class="o">);</span>
                <span class="n">setState</span><span class="o">(</span><span class="n">nextc</span><span class="o">);</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">//没有获取到锁，返回false，则 !tryAcquire(arg) 为true，执行acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span>
        <span class="o">}</span>

</pre></table></code></div></div><p>获取锁失败，线程会进入循环，acquireQueued 方法中for是个无限循环，除非获取锁成功后，才会return。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre><td class="rouge-code"><pre><span class="c1">//获取锁失败后，准备阻塞线程（自己）</span>
<span class="c1">//阻塞之前，添加节点存放到链表，其他线程可以通过这个链表唤醒此线程</span>
<span class="kd">private</span> <span class="nc">Node</span> <span class="nf">addWaiter</span><span class="o">(</span><span class="nc">Node</span> <span class="n">mode</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">(),</span> <span class="n">mode</span><span class="o">);</span> 
        <span class="c1">// Try the fast path of enq; backup to full enq on failure</span>
        <span class="nc">Node</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">pred</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">node</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">pred</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetTail</span><span class="o">(</span><span class="n">pred</span><span class="o">,</span> <span class="n">node</span><span class="o">))</span> <span class="o">{</span><span class="c1">//cas操作</span>
                <span class="n">pred</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
                <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">enq</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
    <span class="o">}</span>

<span class="c1">// 在此方法直到获取锁成功才会跳出循环</span>
<span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">acquireQueued</span><span class="o">(</span><span class="kd">final</span> <span class="nc">Node</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">boolean</span> <span class="n">failed</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="kt">boolean</span> <span class="n">interrupted</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
                <span class="kd">final</span> <span class="nc">Node</span> <span class="n">p</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">predecessor</span><span class="o">();</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">head</span> <span class="o">&amp;&amp;</span> <span class="n">tryAcquire</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">setHead</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
                    <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// help GC</span>
                    <span class="n">failed</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="k">return</span> <span class="n">interrupted</span><span class="o">;</span> <span class="c1">//获取锁成功之后才会return跳出此方法</span>
                <span class="o">}</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">shouldParkAfterFailedAcquire</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">node</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="c1">//如果满足阻塞条件</span>
                    <span class="n">parkAndCheckInterrupt</span><span class="o">())</span> 
                    <span class="n">interrupted</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">failed</span><span class="o">)</span>
                <span class="n">cancelAcquire</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">parkAndCheckInterrupt</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">LockSupport</span><span class="o">.</span><span class="na">park</span><span class="o">(</span><span class="k">this</span><span class="o">);</span><span class="c1">//停止线程（自己）</span>
        <span class="k">return</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">();</span>
    <span class="o">}</span>
</pre></table></code></div></div><h3 id="释放锁">释放锁</h3><p>一个线程拿到锁之后，执行完关键代码，必须unlock释放锁的，否则其他线程永远拿不到锁</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">void</span> <span class="nf">unlock</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">sync</span><span class="o">.</span><span class="na">release</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>

<span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">release</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">tryRelease</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span> <span class="o">{</span>
            <span class="nc">Node</span> <span class="n">h</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">h</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">h</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
                <span class="n">unparkSuccessor</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="c1">//java.util.concurrent.locks.ReentrantLock.Sync 的tryRelease</span>
 <span class="kd">protected</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">tryRelease</span><span class="o">(</span><span class="kt">int</span> <span class="n">releases</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">getState</span><span class="o">()</span> <span class="o">-</span> <span class="n">releases</span><span class="o">;</span> <span class="c1">//这里一般是 1 - 1 = 0</span>
            <span class="k">if</span> <span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">()</span> <span class="o">!=</span> <span class="n">getExclusiveOwnerThread</span><span class="o">())</span> <span class="c1">//只能是锁的拥有者释放锁</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalMonitorStateException</span><span class="o">();</span>
            <span class="kt">boolean</span> <span class="n">free</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">free</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">setState</span><span class="o">(</span><span class="n">c</span><span class="o">);</span> <span class="c1">//设置state为0，相当于释放锁，让其他线程compareAndSetState(0, 1)可能成功</span>
			
            <span class="k">return</span> <span class="n">free</span><span class="o">;</span>
        <span class="o">}</span>

<span class="kd">protected</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">setState</span><span class="o">(</span><span class="kt">int</span> <span class="n">newState</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">newState</span><span class="o">;</span> <span class="c1">//没有cas操作</span>
    <span class="o">}</span>
</pre></table></code></div></div><p>setState不做cas操作是因为，只有拥有锁的线程才调用unlock，不存才并发混乱问题</p><p>其他线程没拿到锁不会设值成功，其他线程在此线程设置state为0之前，compareAndSetState(0, 1)都会失败，拿不到锁，此线程设置state为0之后，其他线程compareAndSetState(0, 1)才有可能成功，返回true从而拿到锁</p><h4 id="释放线程">释放线程</h4><p>线程在获取锁失败后，有可能阻塞线程（自己），在阻塞之前把阻塞线程信息放入链表的 释放锁之后，线程会尝试通过链表释放其他线程（一个），让一个阻塞线程恢复运行</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="kt">void</span> <span class="nf">unparkSuccessor</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">ws</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">waitStatus</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">ws</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
            <span class="n">compareAndSetWaitStatus</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">ws</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
        <span class="nc">Node</span> <span class="n">s</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">s</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">Node</span> <span class="n">t</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span> <span class="n">t</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">node</span><span class="o">;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">prev</span><span class="o">)</span> <span class="c1">// 循环获取前面的节点</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span> <span class="c1">//循环，找到链表最前面需要被唤醒的线程</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
            <span class="nc">LockSupport</span><span class="o">.</span><span class="na">unpark</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">thread</span><span class="o">);</span> <span class="c1">//唤醒（释放）被阻塞的线程</span>
    <span class="o">}</span>
</pre></table></code></div></div><h3 id="阻塞线程被取消阻塞后如何拿到锁reentrantlock中">阻塞线程被取消阻塞后如何拿到锁(ReentrantLock中)</h3><p>有时候线程被中断后，唤醒继续执行后面的代码， 线程没有拿到锁之后主动阻塞自己的，但所还没拿到，被唤醒之后怎么去尝试重新获取锁呢？ 里面有一个for循环</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="kd">final</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetState</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">))</span> 
                <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">());</span><span class="c1">//拿到锁</span>
            <span class="k">else</span>
                <span class="nf">acquire</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> <span class="c1">//没有拿到锁</span>
        <span class="o">}</span>
<span class="c1">// 上锁失败，会添加一个节点，节点包含线程信息，将此节点放入队列</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">acquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">tryAcquire</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
            <span class="n">acquireQueued</span><span class="o">(</span><span class="n">addWaiter</span><span class="o">(</span><span class="nc">Node</span><span class="o">.</span><span class="na">EXCLUSIVE</span><span class="o">),</span> <span class="n">arg</span><span class="o">))</span>
            <span class="n">selfInterrupt</span><span class="o">();</span>
    <span class="o">}</span>

<span class="c1">// 存好节点后，将线程（自己）中断，等其他线程唤醒（自己）</span>
<span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">acquireQueued</span><span class="o">(</span><span class="kd">final</span> <span class="nc">Node</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">boolean</span> <span class="n">failed</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="kt">boolean</span> <span class="n">interrupted</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span><span class="c1">//循环 被唤醒后线程还是在此处循环</span>
                
                <span class="kd">final</span> <span class="nc">Node</span> <span class="n">p</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">predecessor</span><span class="o">();</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">head</span> <span class="o">&amp;&amp;</span> <span class="n">tryAcquire</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span> <span class="o">{</span><span class="c1">//尝试获取锁</span>
                    <span class="n">setHead</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
                    <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// help GC</span>
                    <span class="n">failed</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="k">return</span> <span class="n">interrupted</span><span class="o">;</span> <span class="c1">//如果拿到锁了，才会return</span>
                <span class="o">}</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">shouldParkAfterFailedAcquire</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">node</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
                    <span class="n">parkAndCheckInterrupt</span><span class="o">())</span> <span class="c1">//没拿到锁时，主动中断Thread.currentThread()</span>
                    <span class="n">interrupted</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">failed</span><span class="o">)</span>
                <span class="n">cancelAcquire</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
</pre></table></code></div></div><p>被唤醒后继续执行<code class="language-plaintext highlighter-rouge">compareAndSetState(0, 1)</code>返回false没拿到锁，则继续循环或阻塞</p><p><code class="language-plaintext highlighter-rouge">compareAndSetState(0, 1)</code> 这个操作是获取锁的关键</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/technology-%E6%8A%80%E6%9C%AF/'>Technology^技术</a>, <a href='/categories/java/'>Java</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/writing/" class="post-tag no-text-decoration" >writing</a> <a href="/tags/java/" class="post-tag no-text-decoration" >Java</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=ReentrantLock锁 - Narule&url=https://narule.github.io/posts/Java%E4%B8%AD%E7%9A%84ReentrantLock%E9%94%81/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=ReentrantLock锁 - Narule&u=https://narule.github.io/posts/Java%E4%B8%AD%E7%9A%84ReentrantLock%E9%94%81/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=ReentrantLock锁 - Narule&url=https://narule.github.io/posts/Java%E4%B8%AD%E7%9A%84ReentrantLock%E9%94%81/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%87%E5%BF%98%E5%BD%95/">互联网备忘录</a><li><a href="/posts/%E7%94%A8%E6%88%B7%E6%8C%87%E7%BA%B9/">用户指纹</a><li><a href="/posts/%E5%85%B3%E4%BA%8Enetty/">关于netty</a><li><a href="/posts/%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%AE%BE%E8%AE%A1-The-design-of-an-automatically-updated-blog/">The design of an automatically updated blog | 自动更新博客的设计</a><li><a href="/posts/AbstractQueuedSynchronizer%E6%8A%BD%E8%B1%A1%E7%B1%BB-%E9%98%BB%E5%A1%9E%E9%94%81/">AbstractQueuedSynchronizer抽象类-阻塞锁</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/writing/">writing</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/think/">Think</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/docker/">docker</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/website/">website</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/map/">map</a> <a class="post-tag" href="/tags/nginx/">nginx</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/AbstractQueuedSynchronizer%E6%8A%BD%E8%B1%A1%E7%B1%BB-%E9%98%BB%E5%A1%9E%E9%94%81/"><div class="card-body"> <span class="timeago small" > Mar 20, 2021 <i class="unloaded">2021-03-20T00:10:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>AbstractQueuedSynchronizer抽象类-阻塞锁</h3><div class="text-muted small"><p> AbstractQueuedSynchronizer抽象类-阻塞锁 AbstractQueuedSynchronizer是多线程情况下保证代码快有序运行的一种设计，对多线程获取锁进行了抽象， 设计中包括： 1.线程队列（阻塞的线程） 当很多线程竞争锁的时候，排队一个个获取锁，先进先出 2.线程获取锁，成功就执行后面的代码 3.线程释放锁，如果等待队列中有线程，唤醒队列中的线程 ...</p></div></div></a></div><div class="card"> <a href="/posts/%E5%85%B3%E4%BA%8Enetty/"><div class="card-body"> <span class="timeago small" > Jul 11, 2021 <i class="unloaded">2021-07-11T00:20:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>关于netty</h3><div class="text-muted small"><p> 关于netty netty 是一个非阻塞IO框架，用于Java网络应用开发，特点是异步处理，并发处理能力，netty里面包含有reactor框架的实现，是一个非常高级的框架体系。 netty特性 netty 处理快，更少的资源需求，响应快，可以作为高并发场景服务器的一个选择 reactor 个人理解是 react：响应式， or ：对象，就是响应式框架，netty 就是运用react...</p></div></div></a></div><div class="card"> <a href="/posts/Java-jvm%E8%B0%83%E4%BC%98%E6%96%87%E6%A1%A3%E6%91%98%E8%A6%81/"><div class="card-body"> <span class="timeago small" > Sep 26, 2021 <i class="unloaded">2021-09-26T00:10:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Java-jvm调优文档摘要</h3><div class="text-muted small"><p> Java-jvm调优文档摘要 官方文档：https://docs.oracle.com/en/java/javase/16/gctuning/factors-affecting-garbage-collection-performance.html 关于官方文档的理解，jdk版本不同参数略有区别，特别是jdk1.8之后的改动，取消了永久代这个区域，1.8没有ZGC垃圾回收器，但jdk16...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Tomcat-%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%84%E7%90%86http%E5%B9%B6%E5%8F%91%E8%AF%B7%E6%B1%82/" class="btn btn-outline-primary"><p>Tomcat用线程池处理http并发请求</p></a> <a href="/posts/SpringBoot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" class="btn btn-outline-primary"><p>SpringBoot-启动流程</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="font-italic text-center text-muted small"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> var options = { scriptUrl: '//.disqus.com/embed.js', disqusConfig: function() { this.page.url = 'https://narule.github.io/posts/Java%E4%B8%AD%E7%9A%84ReentrantLock%E9%94%81/'; this.page.identifier = '/posts/Java%E4%B8%AD%E7%9A%84ReentrantLock%E9%94%81/'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://cnblogs.com/narule">narule</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy/" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/writing/">writing</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/think/">Think</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/docker/">docker</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/website/">website</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/map/">map</a> <a class="post-tag" href="/tags/nginx/">nginx</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://narule.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>
