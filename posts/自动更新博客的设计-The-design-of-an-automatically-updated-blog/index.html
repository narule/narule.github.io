<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="theme" content="Chirpy v2.7.2"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="The design of an automatically updated blog 自动更新博客的设计" /><meta name="author" content="Narule" /><meta property="og:locale" content="en_US" /><meta name="description" content="The design of an automatically updated blog | 自动更新博客的设计 Convert markdown note files to blogs, and automatically update blog information 将markdown笔记文件转为博客，且能够自动更新博客信息 博客可以用来记笔记或者发布文章，是一种信息载体，我们可以把一些信息放到博客，方便在网络环境查阅’’ 最近打算搭建个人博客，已知网络上的公共博客网站有博客园（国内），github（全球）都挺好用的，本人有在用，博客园和github也有挂的时候（访问不了），情况很少； 搭建博客能学习不少新知识，自定义功能，下面说说如何设计构建 GitHub源码地址： Selfpublog 功能已经写好可以访问 narule.net/blog 查看效果 created html: created blog json info: blog pageIndex: Object | 功能 Blog site, the content is static files，all access static,reducing server pressure 博客网站，内容是静态文件，所有访问都是静态，减小服务器压力 Operating environment: Linux system, Easier to expand 运行环境：Linux 系统，更容易扩展 Monitor folder changes through shell scripts, monitor the modification of markdown files under the folder, and automatically generate corresponding HTML directories and files 通过shell脚本监控文件夹变化，监控文件夹下markdown文件的修改，自动生成对应的HTML目录和文件 Request | 要求 不能有较多依赖，尽量简单，并且能够较好地扩展（包括前端js html，后端linux） 自动化，除了markdown文件需要人自己上传，其他任何事情包括文章信息更新都自动去完成 markdown 个人认为是一种非常好的写作工具，markdown支持包括图片，表格，简单清晰。 Overall design ideas | 整体设计思路 将写好的markdown文件放入特定文件夹，服务器获得文件信息，将文件转为html文件，并将信息存入文件，使首页能否访问到html文件 access：用静态访问，先有一个index.html文件作为博客访问首页，有一个bloginfo文件用于存放文章（markdown）信息，然后有一个js文件 用于读取bloginfo中的博客信息，并显示在首页 monitor: linux 运行一个监控程序,监控markdown文件夹下面的变化，有文件变化，就获得文件信息并将信息更新到bloginfo markdown2html： 当有文件新增时，将文件转为HTML格式存入博客访问目录（如有markdown文件新增，通过工具将markdown转为html） bloginfo: 生成html文件后，将新增的markdown文章信息更新到bloginfo文件中 Specific plan | 具体实现 accesspage：静态文件访问形式，nginx实现，文件以 html css js为主，index做导航页，js中执行博客信息处理逻辑 filemonitor：文档文件以及文件夹的创建删除等动作监控，使用inotify-tools在linux服务器后台监控 markdown2html：markdown文件转html文件，这里采用markdown2html-converter工具 bloginfo extraction：文章及文件夹信息整理分类，信息采用json文件存储，用jq对文件读写更新信息 功能具体已经实现，本文主要讲linux服务器文件监控动作以及 markdown 文件转 html文件 实现 Accesspage| 网页 博客的静态访问文件，包括文章信息；作为一个可以访问的网站，静态文件访问相对于动态，压力最小，访问也是较快速的 Index Page | 首页 ​ 首页是访问博客首先显示的页面，应该简单明了，不能给人复杂的感觉，主要做导航效果。 ​ 首页元素： ​ 以简洁清晰问主，设立设计展示导航栏，文章目录列表，文章标题列表， 翻页器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 &lt;div id=&quot;indexcontent&quot; style=&quot;text-align: center;&quot;&gt; &lt;div id=&quot;headerHTML&quot;&gt; &lt;h1&gt;页面头&lt;/h1&gt; &lt;/div&gt; &lt;div id=&quot;articleTable&quot;&gt; 文章目录列表 &lt;/div&gt; &lt;div id=&quot;articlelist&quot;&gt; &lt;h3&gt;文章标题1&lt;/h3&gt; &lt;p&gt;摘要&lt;/p&gt; &lt;p&gt;时间&lt;/p&gt; &lt;h3&gt;文章标题2&lt;/h3&gt; &lt;p&gt;摘要&lt;/p&gt; &lt;p&gt;时间&lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;pageTurner&quot;&gt; &lt;h2&gt; &amp;lt; 1 2 3 4 5 &amp;gt; &lt;/h2&gt; 翻页器 &lt;/div&gt; &lt;/div&gt; Index.js Logic | 首页逻辑处理 主要逻辑应该是在页面加载完毕之后，获取bloginfo 数据，遍历提取文章简要信息，并写入首页目录 1 2 3 4 5 window.onload = function () { //get bloginfo //foreache 遍历 //write in articleTable } 按目录归纳文章 1 2 3 //整体逻辑就是 如果 dir=/java/io/ 那么一次创建 java folder 和 io folder //json遍历的时候，根据key 创建dir 具体实现后续更新 //具体效果可以访问 narule.net/blog 按时间归纳文章: 按时间处理文章首页要把文章的时间排序排好，这里是通过天数排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 var BlogInTime = new Map(); //文章存放处 var timeKey = []; //排序工具 /** * 时间字符串转 数字 * time yyyy-mm-dd * 最小单位 日 */ function string2date(timestr){ var arr = timestr.split(&#39;-&#39;); if(arr){ if(arr.length == 1){ return parseInt(arr[0]) * 365; } if(arr.length == 2){ return parseInt(arr[0]) * 365 + parseInt(arr[1]) * 30; } if(arr.length == 3){ return parseInt(arr[0]) * 365 + parseInt(arr[1]) * 30 + parseInt(arr[2]); } } return 0; } /** * 文章时间处理 */ function dealTimeInfo(article){ var time = article.md_time; if(time == &#39;0&#39;){ time = article.create_time; } var articles = BlogInTime.get(time); if(!articles){ articles = []; if(time.indexOf(&#39;-&#39;) != -1){ var timenode = { id: string2date(time), date: time }; timeKey.push(timenode); } } articles.push(article); BlogInTime.set(time,articles); } Filemonitor | 监控 markdown文件如果有变化，需要监听到变化，并且拿到这些markdown文件的信息并存储 有什么工具能够做到监控，也是需要去了解的，查阅资料了解到linux有监听工具inotify-tools可以做到，这里用shell脚本去运行这个程序（后台运行） inotify-tools | 监控工具 系统环境：Linux Centos7 install | 安装 yum install -y epel-release &amp;&amp; yum update 更新资源 yum --enablerepo=epel install inotify-tools 下载安装 use | 使用 inotifywait folder 这是简单表示，实际参数更具具体要求而定，inotifywait表示监听文件夹下的变化 folder就是监听对象 example 如果监听 /home/data/narule/markdown/ 文件夹，之后在/home/data/narule/markdown/创建了java 文件夹 对应的脚本思路： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #!/bin/bash #设置监听的文件夹位置 SRCDIR=/home/data/narule/markdown/ # 启动监听任务：监听create,delete,modify 事件 -e 表示监听事件输出 inotifywait -mqr --timefmt &#39;%d/%m/%y %H:%M&#39; --format &#39;%T %w %f %e&#39; -e &#39;create,delete,modify&#39; $SRCDIR | while read DATE TIME DIR FILE EVENT; # 循环监听逻辑 do echo ${EVENT} #获取信息 #文件夹位置 全路径 DIR=/home/data/narule/markdown/ folder=$DIR #文件名（文件夹也是文件） file=java file=${$FILE} #判断事件类型 if [[ $EVENT == &quot;CREATE,ISDIR&quot; ]]; #创建文件夹 then #执行对应动作 这里创建java文件夹，所以在此处执行相关脚本 elif [[ $EVENT == &quot;MODIFY,ISDIR&quot; ]]; #修改文件夹 then elif [[ $EVENT == &quot;DELETE,ISDIR&quot; ]]; #删除文件夹 then elif [[ $EVENT == &quot;CREATE&quot; ]]; #创建文件 then elif [[ $EVENT == &quot;MODIFY&quot; ]]; #修改文件 then elif [[ $EVENT == &quot;DELETE&quot; ]]; #删除文件 then fi done Markdown2html | 文章转网页格式 markdown文件转为html文件是普遍需求，markdown发布后，将其转为html文件，能够很好的支持网站的访问 很多网站，是直接将markdown文件翻译为html内容，显示在页面，github中也有很多开源的资源，这里采用来自麻省理工？某团队的工具 markdown2html-converter。感谢 markdown2html-converter 系统环境：Linux Centos7 install | 安装 安装前提是你的系统安装了rust动态编程语言 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # rust 安装 安装看看是否能够全局运行 # centos7 curl https://sh.rustup.rs -sSf | sh source $HOME/.cargo/env # 从github获取项目代码 git clone --depth=50 --branch=v1.1.1 https://github.com/magiclen/markdown2html-converter.git cd markdown2html-converter/ # 构建 ## 配置TARGET export TARGET=x86_64-unknown-linux-musl # markdown2html-converter 资源获取 rustup target add $TARGET cargo test --target $TARGET # 编译生成可执行文件 make 官网安装教程 https://travis-ci.org/github/magiclen/markdown2html-converter/jobs/709086971 use | 使用 markdown2html-conventer /path/filename.md -o /path/filename.html Bloginfo extraction| 博客信息提取 文章的信息如何存放，用什么形式存储，会较好理解并且能够解析，这里打算用json数据形式去存储博客的文章信息 **json解析确定后，遇到一些json文件创建和读写的问题，json文件知识包含网站文章的信息，本人觉得不应该运行一个java或者其他什么程序去做这件事，这没必要，浪费资源；最后我在网上找到了jq工具，他可以很好的解析json文件并配合shell修改json文件 jq文档 ** jq | json解析工具 系统环境：Linux Centos7 install | 安装 1 2 3 4 wget http://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm rpm -ivh epel-release-latest-7.noarch.rpm yum repolist yum install -y jq 参考 https://blog.csdn.net/qq_44977042/article/details/89664890 官方文档：https://github.com/stedolan/jq/wiki/Cookbook jq 的使用命令比较多，本人也是刚了解 use | 使用 解析文件 cat file.json | jq . 或者 jq . file.json 前提file.json 内容是正确的json格式，才好正常解析 example author.json： 1 2 3 4 5 { &quot;name&quot;: &quot;rule&quot;, &quot;age&quot;: &quot;2&quot;, &quot;from&quot;: &quot;china&quot; } 执行 cat author.json | jq &#39; .&quot;age&quot; = &quot;5&quot; &#39; 后控制台输出： 1 2 3 4 5 { &quot;name&quot;: &quot;rule&quot;, &quot;age&quot;: &quot;5&quot;, &quot;from&quot;: &quot;china&quot; } 执行 cat author.json | jq &#39; del(.&quot;name&quot;) &#39; 后控制台输出： 1 2 3 4 { &quot;age&quot;: &quot;5&quot;, &quot;from&quot;: &quot;china&quot; } 通过这些命令，就可以处理博客文章信息存储到json文件中，完全自动更新 编写好脚本文件后，给文件加权限使可执行 chmod + x markdown_monitor.sh 后台启动 nohup ./markdown_monitor.sh &gt; /var/log/monitor.log 2&gt;&amp;1 &amp; 就可以监控运作了，上传markdown文件，就自动更新HTML页面到博客 END | 结尾 文件已经放在 github中，拿下来直接可用，唯一需要修改的地方就是文件夹目录 这里整体讲下思路和实现，有些实现并没在本文中写出来，文中目前主要介绍有 后端文件监控及自动将markdown文件转为html文件 转载请注明出处！ ​ 2020-07-25 吴楠予" /><meta property="og:description" content="The design of an automatically updated blog | 自动更新博客的设计 Convert markdown note files to blogs, and automatically update blog information 将markdown笔记文件转为博客，且能够自动更新博客信息 博客可以用来记笔记或者发布文章，是一种信息载体，我们可以把一些信息放到博客，方便在网络环境查阅’’ 最近打算搭建个人博客，已知网络上的公共博客网站有博客园（国内），github（全球）都挺好用的，本人有在用，博客园和github也有挂的时候（访问不了），情况很少； 搭建博客能学习不少新知识，自定义功能，下面说说如何设计构建 GitHub源码地址： Selfpublog 功能已经写好可以访问 narule.net/blog 查看效果 created html: created blog json info: blog pageIndex: Object | 功能 Blog site, the content is static files，all access static,reducing server pressure 博客网站，内容是静态文件，所有访问都是静态，减小服务器压力 Operating environment: Linux system, Easier to expand 运行环境：Linux 系统，更容易扩展 Monitor folder changes through shell scripts, monitor the modification of markdown files under the folder, and automatically generate corresponding HTML directories and files 通过shell脚本监控文件夹变化，监控文件夹下markdown文件的修改，自动生成对应的HTML目录和文件 Request | 要求 不能有较多依赖，尽量简单，并且能够较好地扩展（包括前端js html，后端linux） 自动化，除了markdown文件需要人自己上传，其他任何事情包括文章信息更新都自动去完成 markdown 个人认为是一种非常好的写作工具，markdown支持包括图片，表格，简单清晰。 Overall design ideas | 整体设计思路 将写好的markdown文件放入特定文件夹，服务器获得文件信息，将文件转为html文件，并将信息存入文件，使首页能否访问到html文件 access：用静态访问，先有一个index.html文件作为博客访问首页，有一个bloginfo文件用于存放文章（markdown）信息，然后有一个js文件 用于读取bloginfo中的博客信息，并显示在首页 monitor: linux 运行一个监控程序,监控markdown文件夹下面的变化，有文件变化，就获得文件信息并将信息更新到bloginfo markdown2html： 当有文件新增时，将文件转为HTML格式存入博客访问目录（如有markdown文件新增，通过工具将markdown转为html） bloginfo: 生成html文件后，将新增的markdown文章信息更新到bloginfo文件中 Specific plan | 具体实现 accesspage：静态文件访问形式，nginx实现，文件以 html css js为主，index做导航页，js中执行博客信息处理逻辑 filemonitor：文档文件以及文件夹的创建删除等动作监控，使用inotify-tools在linux服务器后台监控 markdown2html：markdown文件转html文件，这里采用markdown2html-converter工具 bloginfo extraction：文章及文件夹信息整理分类，信息采用json文件存储，用jq对文件读写更新信息 功能具体已经实现，本文主要讲linux服务器文件监控动作以及 markdown 文件转 html文件 实现 Accesspage| 网页 博客的静态访问文件，包括文章信息；作为一个可以访问的网站，静态文件访问相对于动态，压力最小，访问也是较快速的 Index Page | 首页 ​ 首页是访问博客首先显示的页面，应该简单明了，不能给人复杂的感觉，主要做导航效果。 ​ 首页元素： ​ 以简洁清晰问主，设立设计展示导航栏，文章目录列表，文章标题列表， 翻页器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 &lt;div id=&quot;indexcontent&quot; style=&quot;text-align: center;&quot;&gt; &lt;div id=&quot;headerHTML&quot;&gt; &lt;h1&gt;页面头&lt;/h1&gt; &lt;/div&gt; &lt;div id=&quot;articleTable&quot;&gt; 文章目录列表 &lt;/div&gt; &lt;div id=&quot;articlelist&quot;&gt; &lt;h3&gt;文章标题1&lt;/h3&gt; &lt;p&gt;摘要&lt;/p&gt; &lt;p&gt;时间&lt;/p&gt; &lt;h3&gt;文章标题2&lt;/h3&gt; &lt;p&gt;摘要&lt;/p&gt; &lt;p&gt;时间&lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;pageTurner&quot;&gt; &lt;h2&gt; &amp;lt; 1 2 3 4 5 &amp;gt; &lt;/h2&gt; 翻页器 &lt;/div&gt; &lt;/div&gt; Index.js Logic | 首页逻辑处理 主要逻辑应该是在页面加载完毕之后，获取bloginfo 数据，遍历提取文章简要信息，并写入首页目录 1 2 3 4 5 window.onload = function () { //get bloginfo //foreache 遍历 //write in articleTable } 按目录归纳文章 1 2 3 //整体逻辑就是 如果 dir=/java/io/ 那么一次创建 java folder 和 io folder //json遍历的时候，根据key 创建dir 具体实现后续更新 //具体效果可以访问 narule.net/blog 按时间归纳文章: 按时间处理文章首页要把文章的时间排序排好，这里是通过天数排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 var BlogInTime = new Map(); //文章存放处 var timeKey = []; //排序工具 /** * 时间字符串转 数字 * time yyyy-mm-dd * 最小单位 日 */ function string2date(timestr){ var arr = timestr.split(&#39;-&#39;); if(arr){ if(arr.length == 1){ return parseInt(arr[0]) * 365; } if(arr.length == 2){ return parseInt(arr[0]) * 365 + parseInt(arr[1]) * 30; } if(arr.length == 3){ return parseInt(arr[0]) * 365 + parseInt(arr[1]) * 30 + parseInt(arr[2]); } } return 0; } /** * 文章时间处理 */ function dealTimeInfo(article){ var time = article.md_time; if(time == &#39;0&#39;){ time = article.create_time; } var articles = BlogInTime.get(time); if(!articles){ articles = []; if(time.indexOf(&#39;-&#39;) != -1){ var timenode = { id: string2date(time), date: time }; timeKey.push(timenode); } } articles.push(article); BlogInTime.set(time,articles); } Filemonitor | 监控 markdown文件如果有变化，需要监听到变化，并且拿到这些markdown文件的信息并存储 有什么工具能够做到监控，也是需要去了解的，查阅资料了解到linux有监听工具inotify-tools可以做到，这里用shell脚本去运行这个程序（后台运行） inotify-tools | 监控工具 系统环境：Linux Centos7 install | 安装 yum install -y epel-release &amp;&amp; yum update 更新资源 yum --enablerepo=epel install inotify-tools 下载安装 use | 使用 inotifywait folder 这是简单表示，实际参数更具具体要求而定，inotifywait表示监听文件夹下的变化 folder就是监听对象 example 如果监听 /home/data/narule/markdown/ 文件夹，之后在/home/data/narule/markdown/创建了java 文件夹 对应的脚本思路： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #!/bin/bash #设置监听的文件夹位置 SRCDIR=/home/data/narule/markdown/ # 启动监听任务：监听create,delete,modify 事件 -e 表示监听事件输出 inotifywait -mqr --timefmt &#39;%d/%m/%y %H:%M&#39; --format &#39;%T %w %f %e&#39; -e &#39;create,delete,modify&#39; $SRCDIR | while read DATE TIME DIR FILE EVENT; # 循环监听逻辑 do echo ${EVENT} #获取信息 #文件夹位置 全路径 DIR=/home/data/narule/markdown/ folder=$DIR #文件名（文件夹也是文件） file=java file=${$FILE} #判断事件类型 if [[ $EVENT == &quot;CREATE,ISDIR&quot; ]]; #创建文件夹 then #执行对应动作 这里创建java文件夹，所以在此处执行相关脚本 elif [[ $EVENT == &quot;MODIFY,ISDIR&quot; ]]; #修改文件夹 then elif [[ $EVENT == &quot;DELETE,ISDIR&quot; ]]; #删除文件夹 then elif [[ $EVENT == &quot;CREATE&quot; ]]; #创建文件 then elif [[ $EVENT == &quot;MODIFY&quot; ]]; #修改文件 then elif [[ $EVENT == &quot;DELETE&quot; ]]; #删除文件 then fi done Markdown2html | 文章转网页格式 markdown文件转为html文件是普遍需求，markdown发布后，将其转为html文件，能够很好的支持网站的访问 很多网站，是直接将markdown文件翻译为html内容，显示在页面，github中也有很多开源的资源，这里采用来自麻省理工？某团队的工具 markdown2html-converter。感谢 markdown2html-converter 系统环境：Linux Centos7 install | 安装 安装前提是你的系统安装了rust动态编程语言 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # rust 安装 安装看看是否能够全局运行 # centos7 curl https://sh.rustup.rs -sSf | sh source $HOME/.cargo/env # 从github获取项目代码 git clone --depth=50 --branch=v1.1.1 https://github.com/magiclen/markdown2html-converter.git cd markdown2html-converter/ # 构建 ## 配置TARGET export TARGET=x86_64-unknown-linux-musl # markdown2html-converter 资源获取 rustup target add $TARGET cargo test --target $TARGET # 编译生成可执行文件 make 官网安装教程 https://travis-ci.org/github/magiclen/markdown2html-converter/jobs/709086971 use | 使用 markdown2html-conventer /path/filename.md -o /path/filename.html Bloginfo extraction| 博客信息提取 文章的信息如何存放，用什么形式存储，会较好理解并且能够解析，这里打算用json数据形式去存储博客的文章信息 **json解析确定后，遇到一些json文件创建和读写的问题，json文件知识包含网站文章的信息，本人觉得不应该运行一个java或者其他什么程序去做这件事，这没必要，浪费资源；最后我在网上找到了jq工具，他可以很好的解析json文件并配合shell修改json文件 jq文档 ** jq | json解析工具 系统环境：Linux Centos7 install | 安装 1 2 3 4 wget http://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm rpm -ivh epel-release-latest-7.noarch.rpm yum repolist yum install -y jq 参考 https://blog.csdn.net/qq_44977042/article/details/89664890 官方文档：https://github.com/stedolan/jq/wiki/Cookbook jq 的使用命令比较多，本人也是刚了解 use | 使用 解析文件 cat file.json | jq . 或者 jq . file.json 前提file.json 内容是正确的json格式，才好正常解析 example author.json： 1 2 3 4 5 { &quot;name&quot;: &quot;rule&quot;, &quot;age&quot;: &quot;2&quot;, &quot;from&quot;: &quot;china&quot; } 执行 cat author.json | jq &#39; .&quot;age&quot; = &quot;5&quot; &#39; 后控制台输出： 1 2 3 4 5 { &quot;name&quot;: &quot;rule&quot;, &quot;age&quot;: &quot;5&quot;, &quot;from&quot;: &quot;china&quot; } 执行 cat author.json | jq &#39; del(.&quot;name&quot;) &#39; 后控制台输出： 1 2 3 4 { &quot;age&quot;: &quot;5&quot;, &quot;from&quot;: &quot;china&quot; } 通过这些命令，就可以处理博客文章信息存储到json文件中，完全自动更新 编写好脚本文件后，给文件加权限使可执行 chmod + x markdown_monitor.sh 后台启动 nohup ./markdown_monitor.sh &gt; /var/log/monitor.log 2&gt;&amp;1 &amp; 就可以监控运作了，上传markdown文件，就自动更新HTML页面到博客 END | 结尾 文件已经放在 github中，拿下来直接可用，唯一需要修改的地方就是文件夹目录 这里整体讲下思路和实现，有些实现并没在本文中写出来，文中目前主要介绍有 后端文件监控及自动将markdown文件转为html文件 转载请注明出处！ ​ 2020-07-25 吴楠予" /><link rel="canonical" href="https://narule.github.io/posts/%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%AE%BE%E8%AE%A1-The-design-of-an-automatically-updated-blog/" /><meta property="og:url" content="https://narule.github.io/posts/%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%AE%BE%E8%AE%A1-The-design-of-an-automatically-updated-blog/" /><meta property="og:site_name" content="Narule" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-07-25T20:31:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="The design of an automatically updated blog 自动更新博客的设计" /><meta name="twitter:site" content="@no_twitter" /><meta name="twitter:creator" content="@Narule" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"The design of an automatically updated blog | 自动更新博客的设计 Convert markdown note files to blogs, and automatically update blog information 将markdown笔记文件转为博客，且能够自动更新博客信息 博客可以用来记笔记或者发布文章，是一种信息载体，我们可以把一些信息放到博客，方便在网络环境查阅’’ 最近打算搭建个人博客，已知网络上的公共博客网站有博客园（国内），github（全球）都挺好用的，本人有在用，博客园和github也有挂的时候（访问不了），情况很少； 搭建博客能学习不少新知识，自定义功能，下面说说如何设计构建 GitHub源码地址： Selfpublog 功能已经写好可以访问 narule.net/blog 查看效果 created html: created blog json info: blog pageIndex: Object | 功能 Blog site, the content is static files，all access static,reducing server pressure 博客网站，内容是静态文件，所有访问都是静态，减小服务器压力 Operating environment: Linux system, Easier to expand 运行环境：Linux 系统，更容易扩展 Monitor folder changes through shell scripts, monitor the modification of markdown files under the folder, and automatically generate corresponding HTML directories and files 通过shell脚本监控文件夹变化，监控文件夹下markdown文件的修改，自动生成对应的HTML目录和文件 Request | 要求 不能有较多依赖，尽量简单，并且能够较好地扩展（包括前端js html，后端linux） 自动化，除了markdown文件需要人自己上传，其他任何事情包括文章信息更新都自动去完成 markdown 个人认为是一种非常好的写作工具，markdown支持包括图片，表格，简单清晰。 Overall design ideas | 整体设计思路 将写好的markdown文件放入特定文件夹，服务器获得文件信息，将文件转为html文件，并将信息存入文件，使首页能否访问到html文件 access：用静态访问，先有一个index.html文件作为博客访问首页，有一个bloginfo文件用于存放文章（markdown）信息，然后有一个js文件 用于读取bloginfo中的博客信息，并显示在首页 monitor: linux 运行一个监控程序,监控markdown文件夹下面的变化，有文件变化，就获得文件信息并将信息更新到bloginfo markdown2html： 当有文件新增时，将文件转为HTML格式存入博客访问目录（如有markdown文件新增，通过工具将markdown转为html） bloginfo: 生成html文件后，将新增的markdown文章信息更新到bloginfo文件中 Specific plan | 具体实现 accesspage：静态文件访问形式，nginx实现，文件以 html css js为主，index做导航页，js中执行博客信息处理逻辑 filemonitor：文档文件以及文件夹的创建删除等动作监控，使用inotify-tools在linux服务器后台监控 markdown2html：markdown文件转html文件，这里采用markdown2html-converter工具 bloginfo extraction：文章及文件夹信息整理分类，信息采用json文件存储，用jq对文件读写更新信息 功能具体已经实现，本文主要讲linux服务器文件监控动作以及 markdown 文件转 html文件 实现 Accesspage| 网页 博客的静态访问文件，包括文章信息；作为一个可以访问的网站，静态文件访问相对于动态，压力最小，访问也是较快速的 Index Page | 首页 ​ 首页是访问博客首先显示的页面，应该简单明了，不能给人复杂的感觉，主要做导航效果。 ​ 首页元素： ​ 以简洁清晰问主，设立设计展示导航栏，文章目录列表，文章标题列表， 翻页器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 &lt;div id=&quot;indexcontent&quot; style=&quot;text-align: center;&quot;&gt; &lt;div id=&quot;headerHTML&quot;&gt; &lt;h1&gt;页面头&lt;/h1&gt; &lt;/div&gt; &lt;div id=&quot;articleTable&quot;&gt; 文章目录列表 &lt;/div&gt; &lt;div id=&quot;articlelist&quot;&gt; &lt;h3&gt;文章标题1&lt;/h3&gt; &lt;p&gt;摘要&lt;/p&gt; &lt;p&gt;时间&lt;/p&gt; &lt;h3&gt;文章标题2&lt;/h3&gt; &lt;p&gt;摘要&lt;/p&gt; &lt;p&gt;时间&lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;pageTurner&quot;&gt; &lt;h2&gt; &amp;lt; 1 2 3 4 5 &amp;gt; &lt;/h2&gt; 翻页器 &lt;/div&gt; &lt;/div&gt; Index.js Logic | 首页逻辑处理 主要逻辑应该是在页面加载完毕之后，获取bloginfo 数据，遍历提取文章简要信息，并写入首页目录 1 2 3 4 5 window.onload = function () { //get bloginfo //foreache 遍历 //write in articleTable } 按目录归纳文章 1 2 3 //整体逻辑就是 如果 dir=/java/io/ 那么一次创建 java folder 和 io folder //json遍历的时候，根据key 创建dir 具体实现后续更新 //具体效果可以访问 narule.net/blog 按时间归纳文章: 按时间处理文章首页要把文章的时间排序排好，这里是通过天数排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 var BlogInTime = new Map(); //文章存放处 var timeKey = []; //排序工具 /** * 时间字符串转 数字 * time yyyy-mm-dd * 最小单位 日 */ function string2date(timestr){ var arr = timestr.split(&#39;-&#39;); if(arr){ if(arr.length == 1){ return parseInt(arr[0]) * 365; } if(arr.length == 2){ return parseInt(arr[0]) * 365 + parseInt(arr[1]) * 30; } if(arr.length == 3){ return parseInt(arr[0]) * 365 + parseInt(arr[1]) * 30 + parseInt(arr[2]); } } return 0; } /** * 文章时间处理 */ function dealTimeInfo(article){ var time = article.md_time; if(time == &#39;0&#39;){ time = article.create_time; } var articles = BlogInTime.get(time); if(!articles){ articles = []; if(time.indexOf(&#39;-&#39;) != -1){ var timenode = { id: string2date(time), date: time }; timeKey.push(timenode); } } articles.push(article); BlogInTime.set(time,articles); } Filemonitor | 监控 markdown文件如果有变化，需要监听到变化，并且拿到这些markdown文件的信息并存储 有什么工具能够做到监控，也是需要去了解的，查阅资料了解到linux有监听工具inotify-tools可以做到，这里用shell脚本去运行这个程序（后台运行） inotify-tools | 监控工具 系统环境：Linux Centos7 install | 安装 yum install -y epel-release &amp;&amp; yum update 更新资源 yum --enablerepo=epel install inotify-tools 下载安装 use | 使用 inotifywait folder 这是简单表示，实际参数更具具体要求而定，inotifywait表示监听文件夹下的变化 folder就是监听对象 example 如果监听 /home/data/narule/markdown/ 文件夹，之后在/home/data/narule/markdown/创建了java 文件夹 对应的脚本思路： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #!/bin/bash #设置监听的文件夹位置 SRCDIR=/home/data/narule/markdown/ # 启动监听任务：监听create,delete,modify 事件 -e 表示监听事件输出 inotifywait -mqr --timefmt &#39;%d/%m/%y %H:%M&#39; --format &#39;%T %w %f %e&#39; -e &#39;create,delete,modify&#39; $SRCDIR | while read DATE TIME DIR FILE EVENT; # 循环监听逻辑 do echo ${EVENT} #获取信息 #文件夹位置 全路径 DIR=/home/data/narule/markdown/ folder=$DIR #文件名（文件夹也是文件） file=java file=${$FILE} #判断事件类型 if [[ $EVENT == &quot;CREATE,ISDIR&quot; ]]; #创建文件夹 then #执行对应动作 这里创建java文件夹，所以在此处执行相关脚本 elif [[ $EVENT == &quot;MODIFY,ISDIR&quot; ]]; #修改文件夹 then elif [[ $EVENT == &quot;DELETE,ISDIR&quot; ]]; #删除文件夹 then elif [[ $EVENT == &quot;CREATE&quot; ]]; #创建文件 then elif [[ $EVENT == &quot;MODIFY&quot; ]]; #修改文件 then elif [[ $EVENT == &quot;DELETE&quot; ]]; #删除文件 then fi done Markdown2html | 文章转网页格式 markdown文件转为html文件是普遍需求，markdown发布后，将其转为html文件，能够很好的支持网站的访问 很多网站，是直接将markdown文件翻译为html内容，显示在页面，github中也有很多开源的资源，这里采用来自麻省理工？某团队的工具 markdown2html-converter。感谢 markdown2html-converter 系统环境：Linux Centos7 install | 安装 安装前提是你的系统安装了rust动态编程语言 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # rust 安装 安装看看是否能够全局运行 # centos7 curl https://sh.rustup.rs -sSf | sh source $HOME/.cargo/env # 从github获取项目代码 git clone --depth=50 --branch=v1.1.1 https://github.com/magiclen/markdown2html-converter.git cd markdown2html-converter/ # 构建 ## 配置TARGET export TARGET=x86_64-unknown-linux-musl # markdown2html-converter 资源获取 rustup target add $TARGET cargo test --target $TARGET # 编译生成可执行文件 make 官网安装教程 https://travis-ci.org/github/magiclen/markdown2html-converter/jobs/709086971 use | 使用 markdown2html-conventer /path/filename.md -o /path/filename.html Bloginfo extraction| 博客信息提取 文章的信息如何存放，用什么形式存储，会较好理解并且能够解析，这里打算用json数据形式去存储博客的文章信息 **json解析确定后，遇到一些json文件创建和读写的问题，json文件知识包含网站文章的信息，本人觉得不应该运行一个java或者其他什么程序去做这件事，这没必要，浪费资源；最后我在网上找到了jq工具，他可以很好的解析json文件并配合shell修改json文件 jq文档 ** jq | json解析工具 系统环境：Linux Centos7 install | 安装 1 2 3 4 wget http://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm rpm -ivh epel-release-latest-7.noarch.rpm yum repolist yum install -y jq 参考 https://blog.csdn.net/qq_44977042/article/details/89664890 官方文档：https://github.com/stedolan/jq/wiki/Cookbook jq 的使用命令比较多，本人也是刚了解 use | 使用 解析文件 cat file.json | jq . 或者 jq . file.json 前提file.json 内容是正确的json格式，才好正常解析 example author.json： 1 2 3 4 5 { &quot;name&quot;: &quot;rule&quot;, &quot;age&quot;: &quot;2&quot;, &quot;from&quot;: &quot;china&quot; } 执行 cat author.json | jq &#39; .&quot;age&quot; = &quot;5&quot; &#39; 后控制台输出： 1 2 3 4 5 { &quot;name&quot;: &quot;rule&quot;, &quot;age&quot;: &quot;5&quot;, &quot;from&quot;: &quot;china&quot; } 执行 cat author.json | jq &#39; del(.&quot;name&quot;) &#39; 后控制台输出： 1 2 3 4 { &quot;age&quot;: &quot;5&quot;, &quot;from&quot;: &quot;china&quot; } 通过这些命令，就可以处理博客文章信息存储到json文件中，完全自动更新 编写好脚本文件后，给文件加权限使可执行 chmod + x markdown_monitor.sh 后台启动 nohup ./markdown_monitor.sh &gt; /var/log/monitor.log 2&gt;&amp;1 &amp; 就可以监控运作了，上传markdown文件，就自动更新HTML页面到博客 END | 结尾 文件已经放在 github中，拿下来直接可用，唯一需要修改的地方就是文件夹目录 这里整体讲下思路和实现，有些实现并没在本文中写出来，文中目前主要介绍有 后端文件监控及自动将markdown文件转为html文件 转载请注明出处！ ​ 2020-07-25 吴楠予","headline":"The design of an automatically updated blog 自动更新博客的设计","dateModified":"2021-04-02T16:50:15+08:00","datePublished":"2020-07-25T20:31:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://narule.github.io/posts/%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%AE%BE%E8%AE%A1-The-design-of-an-automatically-updated-blog/"},"url":"https://narule.github.io/posts/%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%AE%BE%E8%AE%A1-The-design-of-an-automatically-updated-blog/","author":{"@type":"Person","name":"Narule"},"@type":"BlogPosting","@context":"https://schema.org"}</script><title>The design of an automatically updated blog | 自动更新博客的设计 | Narule</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="preload" href="/assets/css/post.css" as="style"><link rel="stylesheet" href="/assets/css/post.css"><link rel="preload" as="style" href="/assets/css/lib/bootstrap-toc.min.css"><link rel="stylesheet" href="/assets/css/lib/bootstrap-toc.min.css" /> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="/assets/js/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-JVHJ82NYZT"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-JVHJ82NYZT'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://narule.github.io/avatar.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Narule</a></div><div class="site-subtitle font-italic">A Blog for Article; Chinese Blog is www.cnblogs.com/narule</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tabs/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tabs/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/tabs/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/tabs/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/narule" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/no_twitter" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['narule','163.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>The design of an automatically updated blog | 自动更新博客的设计</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>The design of an automatically updated blog | 自动更新博客的设计</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sat, Jul 25, 2020, 8:31 PM +0800" > Jul 25, 2020 <i class="unloaded">2020-07-25T20:31:00+08:00</i> </span> by <span class="author"> Narule </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Fri, Apr 2, 2021, 4:50 PM +0800" > Apr 2, 2021 <i class="unloaded">2021-04-02T16:50:15+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2668 words">14 min</span></div></div><div class="post-content"><h1 id="the-design-of-an-automatically-updated-blog--自动更新博客的设计">The design of an automatically updated blog | 自动更新博客的设计</h1><blockquote><p>Convert markdown note files to blogs, and automatically update blog information</p><p>将markdown笔记文件转为博客，且能够自动更新博客信息</p></blockquote><p>博客可以用来记笔记或者发布文章，是一种信息载体，我们可以把一些信息放到博客，方便在网络环境查阅’’</p><p>最近打算搭建个人博客，已知网络上的公共博客网站有博客园（国内），github（全球）都挺好用的，本人有在用，博客园和github也有挂的时候（访问不了），情况很少；</p><p>搭建博客能学习不少新知识，自定义功能，下面说说如何设计构建</p><p><strong>GitHub源码地址：</strong> <a href="https://github.com/narule/Selfpublog">Selfpublog</a></p><p>功能已经写好可以访问 <a href="http://narule.net/blog">narule.net/blog</a> 查看效果</p><p>created html:<br /> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/narule/Selfpublog/blob/master/blogimage/selfpublogresult.PNG" alt="" /></p><p>created blog json info:<br /> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/narule/Selfpublog/blob/master/blogimage/selfpublog-json.PNG" alt="" /></p><p>blog pageIndex:<br /> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/narule/Selfpublog/blob/master/blogimage/indexfolder.PNG" alt="" /></p><h2 id="object--功能">Object | 功能</h2><ol><li><p>Blog site, the content is static files，all access static,reducing server pressure</p><p>博客网站，内容是静态文件，所有访问都是静态，减小服务器压力</p><li><p>Operating environment: Linux system, Easier to expand</p><p>运行环境：Linux 系统，更容易扩展</p><li><p>Monitor folder changes through shell scripts, monitor the modification of markdown files under the folder, and automatically generate corresponding HTML directories and files</p><p>通过shell脚本监控文件夹变化，监控文件夹下markdown文件的修改，自动生成对应的HTML目录和文件</p></ol><h3 id="request--要求">Request | 要求</h3><ol><li>不能有较多依赖，尽量简单，并且能够较好地扩展（包括前端js html，后端linux）<li>自动化，除了markdown文件需要人自己上传，其他任何事情包括文章信息更新都自动去完成</ol><p>markdown 个人认为是一种非常好的写作工具，markdown支持包括图片，表格，简单清晰。</p><h2 id="overall-design-ideas--整体设计思路">Overall design ideas | 整体设计思路</h2><blockquote><p>将写好的markdown文件放入特定文件夹，服务器获得文件信息，将文件转为html文件，并将信息存入文件，使首页能否访问到html文件</p></blockquote><ol><li>access：用静态访问，先有一个index.html文件作为博客访问首页，有一个bloginfo文件用于存放文章（markdown）信息，然后有一个js文件 用于读取bloginfo中的博客信息，并显示在首页<li>monitor: linux 运行一个监控程序,监控markdown文件夹下面的变化，有文件变化，就获得文件信息并将信息更新到bloginfo<li>markdown2html： 当有文件新增时，将文件转为HTML格式存入博客访问目录（如有markdown文件新增，通过工具将markdown转为html）<li>bloginfo: 生成html文件后，将新增的markdown文章信息更新到bloginfo文件中</ol><h2 id="specific-plan--具体实现">Specific plan | 具体实现</h2><ol><li>accesspage：静态文件访问形式，nginx实现，文件以 html css js为主，index做导航页，js中执行博客信息处理逻辑<li>filemonitor：文档文件以及文件夹的创建删除等动作监控，使用inotify-tools在linux服务器后台监控<li>markdown2html：markdown文件转html文件，这里采用markdown2html-converter工具<li>bloginfo extraction：文章及文件夹信息整理分类，信息采用json文件存储，用jq对文件读写更新信息</ol><p>功能具体已经实现，本文主要讲linux服务器文件监控动作以及 markdown 文件转 html文件 实现</p><h3 id="accesspage-网页">Accesspage| 网页</h3><blockquote><p>博客的静态访问文件，包括文章信息；作为一个可以访问的网站，静态文件访问相对于动态，压力最小，访问也是较快速的</p></blockquote><h4 id="index-page--首页">Index Page | 首页</h4><p>​ 首页是访问博客首先显示的页面，应该简单明了，不能给人复杂的感觉，主要做导航效果。</p><p>​ 首页元素：</p><p>​ 以简洁清晰问主，设立设计展示导航栏，文章目录列表，文章标题列表， 翻页器</p><div class="language-html highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">"indexcontent"</span> <span class="na">style=</span><span class="s">"text-align: center;"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">"headerHTML"</span><span class="nt">&gt;</span>
                <span class="nt">&lt;h1&gt;</span>页面头<span class="nt">&lt;/h1&gt;</span>
            <span class="nt">&lt;/div&gt;</span>
            <span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">"articleTable"</span><span class="nt">&gt;</span>
            	文章目录列表
			<span class="nt">&lt;/div&gt;</span>
            <span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">"articlelist"</span><span class="nt">&gt;</span>
                <span class="nt">&lt;h3&gt;</span>文章标题1<span class="nt">&lt;/h3&gt;</span>
                <span class="nt">&lt;p&gt;</span>摘要<span class="nt">&lt;/p&gt;</span>
                <span class="nt">&lt;p&gt;</span>时间<span class="nt">&lt;/p&gt;</span>
                <span class="nt">&lt;h3&gt;</span>文章标题2<span class="nt">&lt;/h3&gt;</span>
                <span class="nt">&lt;p&gt;</span>摘要<span class="nt">&lt;/p&gt;</span>
                <span class="nt">&lt;p&gt;</span>时间<span class="nt">&lt;/p&gt;</span>
            <span class="nt">&lt;/div&gt;</span>
            <span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">"pageTurner"</span><span class="nt">&gt;</span>
                <span class="nt">&lt;h2&gt;</span>
                    <span class="ni">&amp;lt;</span> 1 2 3 4 5 <span class="ni">&amp;gt;</span>
                <span class="nt">&lt;/h2&gt;</span> 翻页器
            <span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</pre></table></code></div></div><h4 id="indexjs-logic--首页逻辑处理">Index.js Logic | 首页逻辑处理</h4><p>主要逻辑应该是在页面加载完毕之后，获取bloginfo 数据，遍历提取文章简要信息，并写入首页目录</p><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nb">window</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">//get bloginfo</span>
    <span class="c1">//foreache 遍历</span>
    <span class="c1">//write in articleTable</span>
<span class="p">}</span>
</pre></table></code></div></div><p>按目录归纳文章</p><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="c1">//整体逻辑就是  如果 dir=/java/io/ 那么一次创建  java folder 和 io folder</span>
<span class="c1">//json遍历的时候，根据key 创建dir 具体实现后续更新</span>
<span class="c1">//具体效果可以访问  narule.net/blog</span>
</pre></table></code></div></div><p>按时间归纳文章:</p><p>按时间处理文章首页要把文章的时间排序排好，这里是通过天数排序</p><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre><td class="rouge-code"><pre><span class="kd">var</span> <span class="nx">BlogInTime</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span> <span class="c1">//文章存放处</span>
<span class="kd">var</span> <span class="nx">timeKey</span> <span class="o">=</span> <span class="p">[];</span> <span class="c1">//排序工具</span>
<span class="cm">/**
 * 时间字符串转 数字
 * time yyyy-mm-dd
 * 最小单位 日
 */</span>
<span class="kd">function</span> <span class="nx">string2date</span><span class="p">(</span><span class="nx">timestr</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">arr</span> <span class="o">=</span> <span class="nx">timestr</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">'</span><span class="s1">-</span><span class="dl">'</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">arr</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">==</span> <span class="mi">1</span><span class="p">){</span>
            <span class="k">return</span> <span class="nb">parseInt</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="mi">365</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">==</span> <span class="mi">2</span><span class="p">){</span>
            <span class="k">return</span> <span class="nb">parseInt</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="mi">365</span> <span class="o">+</span> <span class="nb">parseInt</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="mi">30</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">==</span> <span class="mi">3</span><span class="p">){</span>
            <span class="k">return</span> <span class="nb">parseInt</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="mi">365</span> <span class="o">+</span> <span class="nb">parseInt</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="mi">30</span> <span class="o">+</span> <span class="nb">parseInt</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**
 * 文章时间处理
 */</span>
<span class="kd">function</span> <span class="nx">dealTimeInfo</span><span class="p">(</span><span class="nx">article</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">time</span> <span class="o">=</span> <span class="nx">article</span><span class="p">.</span><span class="nx">md_time</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">time</span> <span class="o">==</span> <span class="dl">'</span><span class="s1">0</span><span class="dl">'</span><span class="p">){</span>
        <span class="nx">time</span> <span class="o">=</span> <span class="nx">article</span><span class="p">.</span><span class="nx">create_time</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">var</span> <span class="nx">articles</span> <span class="o">=</span> <span class="nx">BlogInTime</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">time</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">articles</span><span class="p">){</span>
        <span class="nx">articles</span> <span class="o">=</span> <span class="p">[];</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="dl">'</span><span class="s1">-</span><span class="dl">'</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
            <span class="kd">var</span> <span class="nx">timenode</span> <span class="o">=</span> 
            <span class="p">{</span>
                <span class="na">id</span><span class="p">:</span> <span class="nx">string2date</span><span class="p">(</span><span class="nx">time</span><span class="p">),</span>
                <span class="na">date</span><span class="p">:</span> <span class="nx">time</span>
            <span class="p">};</span>
            <span class="nx">timeKey</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">timenode</span><span class="p">);</span>
        <span class="p">}</span>
        
    <span class="p">}</span>
    <span class="nx">articles</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">article</span><span class="p">);</span>
    <span class="nx">BlogInTime</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">time</span><span class="p">,</span><span class="nx">articles</span><span class="p">);</span>

<span class="p">}</span>

</pre></table></code></div></div><h3 id="filemonitor--监控">Filemonitor | 监控</h3><blockquote><p>markdown文件如果有变化，需要监听到变化，并且拿到这些markdown文件的信息并存储</p></blockquote><p><strong>有什么工具能够做到监控，也是需要去了解的，查阅资料了解到linux有监听工具<a href="https://github.com/inotify-tools/inotify-tools">inotify-tools</a>可以做到，这里用shell脚本去运行这个程序（后台运行）</strong></p><h4 id="inotify-tools--监控工具">inotify-tools | 监控工具</h4><p>系统环境：Linux Centos7</p><h5 id="install--安装">install | 安装</h5><p><code class="language-plaintext highlighter-rouge">yum install -y epel-release &amp;&amp; yum update</code> 更新资源</p><p><code class="language-plaintext highlighter-rouge">yum --enablerepo=epel install inotify-tools</code> 下载安装</p><h5 id="use--使用">use | 使用</h5><p><code class="language-plaintext highlighter-rouge">inotifywait folder </code> 这是简单表示，实际参数更具具体要求而定，inotifywait表示监听文件夹下的变化 folder就是监听对象</p><p>example</p><p>如果监听 /home/data/narule/markdown/ 文件夹，之后在/home/data/narule/markdown/创建了java 文件夹</p><p>对应的脚本思路：</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre><span class="c">#!/bin/bash</span>

<span class="c">#设置监听的文件夹位置</span>
<span class="nv">SRCDIR</span><span class="o">=</span>/home/data/narule/markdown/  


<span class="c"># 启动监听任务：监听create,delete,modify 事件  -e 表示监听事件输出 </span>
inotifywait <span class="nt">-mqr</span> <span class="nt">--timefmt</span> <span class="s1">'%d/%m/%y %H:%M'</span> <span class="nt">--format</span> <span class="s1">'%T %w %f %e'</span> <span class="nt">-e</span> <span class="s1">'create,delete,modify'</span> <span class="nv">$SRCDIR</span> | <span class="k">while </span><span class="nb">read </span>DATE TIME DIR FILE EVENT<span class="p">;</span>


<span class="c"># 循环监听逻辑</span>
<span class="k">do
	</span><span class="nb">echo</span> <span class="k">${</span><span class="nv">EVENT</span><span class="k">}</span>
	<span class="c">#获取信息</span>
	<span class="c">#文件夹位置  全路径 DIR=/home/data/narule/markdown/</span>
    <span class="nv">folder</span><span class="o">=</span><span class="nv">$DIR</span> 
    <span class="c">#文件名（文件夹也是文件）  file=java</span>
    <span class="nv">file</span><span class="o">=</span><span class="k">${</span><span class="nv">$FILE</span><span class="k">}</span> 
    
    
    <span class="c">#判断事件类型</span>
    <span class="k">if</span> <span class="o">[[</span> <span class="nv">$EVENT</span> <span class="o">==</span> <span class="s2">"CREATE,ISDIR"</span> <span class="o">]]</span><span class="p">;</span> <span class="c">#创建文件夹 </span>
    	<span class="k">then</span> <span class="c">#执行对应动作 这里创建java文件夹，所以在此处执行相关脚本</span>
    		
    <span class="k">elif</span> <span class="o">[[</span> <span class="nv">$EVENT</span> <span class="o">==</span> <span class="s2">"MODIFY,ISDIR"</span> <span class="o">]]</span><span class="p">;</span> <span class="c">#修改文件夹</span>
    	<span class="k">then
    
    elif</span> <span class="o">[[</span> <span class="nv">$EVENT</span> <span class="o">==</span> <span class="s2">"DELETE,ISDIR"</span> <span class="o">]]</span><span class="p">;</span> <span class="c">#删除文件夹</span>
    	<span class="k">then
    
    elif</span>  <span class="o">[[</span> <span class="nv">$EVENT</span> <span class="o">==</span> <span class="s2">"CREATE"</span> <span class="o">]]</span><span class="p">;</span> <span class="c">#创建文件</span>
    	<span class="k">then
    
    elif</span> <span class="o">[[</span> <span class="nv">$EVENT</span> <span class="o">==</span> <span class="s2">"MODIFY"</span> <span class="o">]]</span><span class="p">;</span> <span class="c">#修改文件</span>
    	<span class="k">then
    	
    elif</span> <span class="o">[[</span> <span class="nv">$EVENT</span> <span class="o">==</span> <span class="s2">"DELETE"</span> <span class="o">]]</span><span class="p">;</span> <span class="c">#删除文件</span>
    	<span class="k">then
    	
    fi
done</span>
</pre></table></code></div></div><h3 id="markdown2html--文章转网页格式">Markdown2html | 文章转网页格式</h3><blockquote><p>markdown文件转为html文件是普遍需求，markdown发布后，将其转为html文件，能够很好的支持网站的访问</p></blockquote><p><strong>很多网站，是直接将markdown文件翻译为html内容，显示在页面，github中也有很多开源的资源，这里采用来自麻省理工？某团队的工具 <a href="https://github.com/magiclen/markdown2html-converter">markdown2html-converter</a>。感谢</strong></p><h4 id="markdown2html-converter">markdown2html-converter</h4><p>系统环境：Linux Centos7</p><h5 id="install--安装-1">install | 安装</h5><p>安装前提是你的系统安装了rust动态编程语言</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="c"># rust 安装 安装看看是否能够全局运行</span>
<span class="c"># centos7</span>
curl https://sh.rustup.rs <span class="nt">-sSf</span> | sh

<span class="nb">source</span> <span class="nv">$HOME</span>/.cargo/env

<span class="c"># 从github获取项目代码</span>
git clone <span class="nt">--depth</span><span class="o">=</span>50 <span class="nt">--branch</span><span class="o">=</span>v1.1.1 https://github.com/magiclen/markdown2html-converter.git 

<span class="nb">cd </span>markdown2html-converter/
<span class="c"># 构建</span>
<span class="c">## 配置TARGET</span>
<span class="nb">export </span><span class="nv">TARGET</span><span class="o">=</span>x86_64-unknown-linux-musl

<span class="c"># markdown2html-converter 资源获取</span>
rustup target add <span class="nv">$TARGET</span>
cargo <span class="nb">test</span> <span class="nt">--target</span> <span class="nv">$TARGET</span>

<span class="c"># 编译生成可执行文件</span>
make
</pre></table></code></div></div><p>官网安装教程 https://travis-ci.org/github/magiclen/markdown2html-converter/jobs/709086971</p><h5 id="use--使用-1">use | 使用</h5><p>markdown2html-conventer /path/filename.md -o /path/filename.html</p><h3 id="bloginfo-extraction-博客信息提取">Bloginfo extraction| 博客信息提取</h3><blockquote><p>文章的信息如何存放，用什么形式存储，会较好理解并且能够解析，这里打算用json数据形式去存储博客的文章信息</p></blockquote><p>**json解析确定后，遇到一些json文件创建和读写的问题，json文件知识包含网站文章的信息，本人觉得不应该运行一个java或者其他什么程序去做这件事，这没必要，浪费资源；最后我在网上找到了<a href="https://github.com/stedolan/jq">jq</a>工具，他可以很好的解析json文件并配合shell修改json文件 <a href="https://stedolan.github.io/jq/manual/">jq文档</a> **</p><h4 id="jq---json解析工具">jq | json解析工具</h4><p>系统环境：Linux Centos7</p><h5 id="install--安装-2">install | 安装</h5><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>wget http://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm
rpm <span class="nt">-ivh</span> epel-release-latest-7.noarch.rpm
yum repolist
yum <span class="nb">install</span> <span class="nt">-y</span> jq
</pre></table></code></div></div><p>参考 https://blog.csdn.net/qq_44977042/article/details/89664890</p><p>官方文档：https://github.com/stedolan/jq/wiki/Cookbook</p><p>jq 的使用命令比较多，本人也是刚了解</p><h5 id="use--使用-2">use | 使用</h5><p>解析文件</p><p><code class="language-plaintext highlighter-rouge">cat file.json | jq .</code> 或者 jq . file.json</p><p>前提file.json 内容是正确的json格式，才好正常解析</p><p>example</p><p>author.json：</p><div class="language-json highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="p">{</span><span class="w">
    </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"rule"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"age"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"from"</span><span class="p">:</span><span class="w"> </span><span class="s2">"china"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></pre></table></code></div></div><p>执行 <code class="language-plaintext highlighter-rouge">cat author.json | jq ' ."age" = "5" '</code> 后控制台输出：</p><div class="language-json highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="p">{</span><span class="w">
    </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"rule"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"age"</span><span class="p">:</span><span class="w"> </span><span class="s2">"5"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"from"</span><span class="p">:</span><span class="w"> </span><span class="s2">"china"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></pre></table></code></div></div><p>执行 <code class="language-plaintext highlighter-rouge">cat author.json | jq ' del(."name") '</code> 后控制台输出：</p><div class="language-json highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="p">{</span><span class="w">
    </span><span class="nl">"age"</span><span class="p">:</span><span class="w"> </span><span class="s2">"5"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"from"</span><span class="p">:</span><span class="w"> </span><span class="s2">"china"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></pre></table></code></div></div><p>通过这些命令，就可以处理博客文章信息存储到json文件中，完全自动更新</p><p>编写好脚本文件后，给文件加权限使可执行</p><p><code class="language-plaintext highlighter-rouge">chmod + x markdown_monitor.sh</code></p><p>后台启动</p><p><code class="language-plaintext highlighter-rouge">nohup ./markdown_monitor.sh &gt; /var/log/monitor.log 2&gt;&amp;1 &amp;</code></p><p>就可以监控运作了，上传markdown文件，就自动更新HTML页面到博客</p><h2 id="end--结尾">END | 结尾</h2><p>文件已经放在 github中，拿下来直接可用，唯一需要修改的地方就是文件夹目录</p><p>这里整体讲下思路和实现，有些实现并没在本文中写出来，文中目前主要介绍有 后端文件监控及自动将markdown文件转为html文件</p><p>转载请注明出处！</p><hr /><p>​ 2020-07-25 吴楠予</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/technology-%E6%8A%80%E6%9C%AF/'>Technology^技术</a>, <a href='/categories/website-%E7%BD%91%E7%AB%99/'>Website^网站</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/writing/" class="post-tag no-text-decoration" >writing</a> <a href="/tags/website/" class="post-tag no-text-decoration" >website</a> <a href="/tags/blog/" class="post-tag no-text-decoration" >blog</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=The design of an automatically updated blog | 自动更新博客的设计 - Narule&url=https://narule.github.io/posts/%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%AE%BE%E8%AE%A1-The-design-of-an-automatically-updated-blog/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=The design of an automatically updated blog | 自动更新博客的设计 - Narule&u=https://narule.github.io/posts/%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%AE%BE%E8%AE%A1-The-design-of-an-automatically-updated-blog/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=The design of an automatically updated blog | 自动更新博客的设计 - Narule&url=https://narule.github.io/posts/%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%AE%BE%E8%AE%A1-The-design-of-an-automatically-updated-blog/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%87%E5%BF%98%E5%BD%95/">互联网备忘录</a><li><a href="/posts/%E7%94%A8%E6%88%B7%E6%8C%87%E7%BA%B9/">用户指纹</a><li><a href="/posts/%E5%85%B3%E4%BA%8Enetty/">关于netty</a><li><a href="/posts/%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%AE%BE%E8%AE%A1-The-design-of-an-automatically-updated-blog/">The design of an automatically updated blog | 自动更新博客的设计</a><li><a href="/posts/AbstractQueuedSynchronizer%E6%8A%BD%E8%B1%A1%E7%B1%BB-%E9%98%BB%E5%A1%9E%E9%94%81/">AbstractQueuedSynchronizer抽象类-阻塞锁</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/writing/">writing</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/think/">Think</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/docker/">docker</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/website/">website</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/map/">map</a> <a class="post-tag" href="/tags/nginx/">nginx</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/%E7%94%A8%E6%88%B7%E6%8C%87%E7%BA%B9/"><div class="card-body"> <span class="timeago small" > Jun 29, 2022 <i class="unloaded">2022-06-29T21:31:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>用户指纹</h3><div class="text-muted small"><p> 用户指纹 用户 （灵识）user 设计上来说 用户是独一无二的，用户在创建时不会有第二次创建 灵魂标记账号 在考虑用户的个性化和安全上，账号应该是独一无二的，这种账号应该是只有本人才能登陆的账号。 构思上来说，灵魂时独一无二的，所以电脑也不能把一个独一无二的灵魂保存到数据库，但是我们可以录入灵魂指纹。就像人的指纹时独一无二的一样，灵魂指纹也是如此且更抽象。</p></div></div></a></div><div class="card"> <a href="/posts/%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%87%E5%BF%98%E5%BD%95/"><div class="card-body"> <span class="timeago small" > Oct 4, 2020 <i class="unloaded">2020-10-04T20:31:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>互联网备忘录</h3><div class="text-muted small"><p> 互联网备忘录 写一个服务，保存个人信息到互联网方便查看，支持终端加密 写了一个互联网信息备忘录，数据存储使用mysql 互联网通信https证书加密，备份加密Aes加密，用户自己保存密钥，用户需要使用邮箱注册账号 服务地址： miji.sntree.cn 内容 用户登录后 1.保存用户个人数据到服务端 2.保存数据到服务端前可在客户端加密 3.客户端信息查看（服务...</p></div></div></a></div><div class="card"> <a href="/posts/Problem-%E8%AF%BE%E9%A2%98/"><div class="card-body"> <span class="timeago small" > Jul 10, 2020 <i class="unloaded">2020-07-10T22:01:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Problem^^课题</h3><div class="text-muted small"><p> 有时候有些事情做起来，会比较困难，可以先立一个课题去了解他，再看看要不要做</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Problem-%E8%AF%BE%E9%A2%98/" class="btn btn-outline-primary"><p>Problem^^课题</p></a> <a href="/posts/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/" class="btn btn-outline-primary"><p>关于博客</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="font-italic text-center text-muted small"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> var options = { scriptUrl: '//.disqus.com/embed.js', disqusConfig: function() { this.page.url = 'https://narule.github.io/posts/%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%AE%BE%E8%AE%A1-The-design-of-an-automatically-updated-blog/'; this.page.identifier = '/posts/%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%AE%BE%E8%AE%A1-The-design-of-an-automatically-updated-blog/'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://cnblogs.com/narule">narule</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy/" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/writing/">writing</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/think/">Think</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/docker/">docker</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/website/">website</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/map/">map</a> <a class="post-tag" href="/tags/nginx/">nginx</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://narule.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>
